---
title: '暑期集训 W1 个人题解 (0716 - 0721)'
description: ''
publishDate: 2024-07-21
tags:
  - 总结
  - ACM
---
<!-- more -->
## 牛客多校02 :

### [B - MST](https://ac.nowcoder.com/acm/contest/81597/B)

考虑根号分治

关键点数量 $k_i \leq \sqrt{m}$ 时，子图中最多有  $\frac {k_i * (k_i - 1)} {2} < m$  条边，直接用 `map` $k^2$ 找出所有的边

这部分的复杂度为 $O(\Sigma {k_i}^2 log(m)) \leq O(mlogm)$

一个小 trick 就是查看 map 存不存在时用 count，直接访问会导致 map 越来越大

关键点数量 $k_i \geq \sqrt{m}$ 时，遍历所有关键点的每条边建图

这部分的复杂度是 $O(m · \Sigma\frac{n}{k_i}) \leq O(m\sqrt{m})$

每次建完图单独跑最小生成树就能过

本来以为是偷鸡成功，没想到是出题人仁慈放过 log （

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 1e5 + 5;
const LL inf = 1e18;

int n, m, Q;
int a[maxn];
int vis[maxn];

int head[maxn], nxt[maxn << 1], to[maxn << 1], w[maxn << 1], cnt;
int khead[maxn], knxt[maxn << 1], kto[maxn << 1], kw[maxn << 1], kcnt;

void in(int x, int y, int z) {
    nxt[++cnt] = head[x], head[x] = cnt, to[cnt] = y, w[cnt] = z;
}
void kin(int x, int y, int z) {
    knxt[++kcnt] = khead[x], khead[x] = kcnt, kto[kcnt] = y, kw[kcnt] = z;
}

int v[maxn];
LL dis[maxn];
struct node {
    LL dis;
    int id;
};
bool operator < (node x, node y) {
    if (x.dis != y.dis) return x.dis > y.dis;
    return x.id > y.id;
}
struct node2 {
    int y, z;
};
bool operator < (node2 x, node2 y) {
    return x.y < y.y;
}
set<node2> st[maxn];

int main()
{

    n = read(); m = read(); Q = read();
    for (int i = 1; i <= m; i++) {
        int x, y, z;
        x = read(); y = read(); z = read();
        in(x, y, z); in(y, x, z);
        st[x].insert({y, z}), st[y].insert({x, z});
    }
    int len = sqrt(m);

    while (Q--) {
        int k;
        k = read();

        for (int i = 1; i <= k; i++) {
            a[i] = read(), vis[a[i]] = 1;
            dis[a[i]] = inf, v[a[i]] = 0;
        }

        if (k <= len) {
            for (int i = 1; i < k; i++)
                for (int j = i + 1; j <= k; j++) {
                    int si = st[a[i]].size(), sj = st[a[j]].size();
                    int x = a[i], y = a[j];
                    if (si > sj) swap(x, y);
                    auto it = st[x].find({y, 0});
                    if (it != st[x].end()) kin(a[j], a[i], (*it).z), kin(a[i], a[j], (*it).z);
                }
        } else {
            for (int i = 1; i <= k; i++) {
                for (int j = head[a[i]]; j; j = nxt[j]) {
                    if (vis[to[j]]) kin(a[i], to[j], w[j]);
                }
            }
        }

        priority_queue<node> q;
        dis[a[1]] = 0;
        q.push({0, a[1]});
        int num = 0;
        LL ans = 0;

        while (!q.empty()) {
            auto [d, id] = q.top();
            q.pop();
            if (v[id]) continue;
            
            num++;
            ans += d;
            v[id] = 1;
            for (int j = khead[id]; j; j = knxt[j]) {
                if (kw[j] < dis[kto[j]]) {
                    dis[kto[j]] = kw[j];
                    q.push({dis[kto[j]], kto[j]});
                }
            }
        }
        if (num == k) printf("%lld\n", ans);
            else printf("-1\n");

        for (int i = 1; i <= k; i++) khead[a[i]] = 0, vis[a[i]] = 0;
        kcnt = 0;
    }

    return 0;
}
```

### [C - Red Walking on Grid](https://ac.nowcoder.com/acm/contest/81597/C)

签到 1，但是 WA 了两次（

从每个左侧点跑 dfs ，优先上下移动，上下走不动了再往右走就能找到最优解

### [E - GCD VS XOR](https://ac.nowcoder.com/acm/contest/81597/E)

签到 2

当 $n \neq lowbit(n)$ 时，一个可行解是 $n - lowbit(n)$

否则无解

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

LL read() {
    LL x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

int T;
LL n;

LL lowbit(LL x) {
    return x & (-x);
}

int main()
{
    T = read();
    while (T--) {
        n = read();
        LL ans = n - lowbit(n);
        if (ans) printf("%lld\n", ans);
            else printf("-1\n");
    }

    return 0;
}
```
 
### [G - The Set of Squares](https://ac.nowcoder.com/acm/contest/81597/G)

因为 $a_i \leq 1000$ ，所以 $a_i$ 中出现两次的质因数不会超过 $\sqrt{1000}$ ，一共有 11 个

所以一个数可以分解为这 11 个数的出现次数的奇偶行再加上一个大质数（或者1），这个数一定产生的贡献 $w$ 就是 $\prod p_i^{\lfloor \frac {cnt_i} {2} \rfloor}$ ， $cnt_i$ 为该质数出现的次数

我们把这 11 个质数数出现的奇偶性作为这个数的体积，最后选择的数字一定要满足体积的异或和为 $0$ （即每个质数的出现次数都为偶数），那么考虑用 $dp_{i, S}$ 表示选到第 $i$ 个数，这 11 个质数的状态为 $S$ 时的答案，所求的答案就是 $dp_{n, 0}$

先按照每个数对应的大质数分组，然后考虑如何转移，对于第 $i$ 个数，假设它的体积为 $v$ ，当前已经枚举到的状态为 j，那么选择这个数后的状态为 $v \oplus j$ ，选择这个数新产生的贡献就是 $dp_{i - 1, j} * w * \prod_{2 ^ k \in v, 2 ^ k \in j} p_k$ 

解释一下就是当 $j$ 和 $v$ 的某一位均为 1 时，这两个 1 作为多出的奇数部分没有被记入任何一个数的贡献，选上 $v$ 后就能产生一个 $p_k$ 的贡献

转移为 $dp_{i, j \oplus v} = dp_{i, j \oplus v} + dp_{i - 1, j} * w * \prod_{2^k \in v, 2 ^ k \in j} p_k$ ，用滚动数组可以压掉一维

当一个数的大质数部分不是 1 时，我们可以加入第 12 个 "质数"，大小为这个大质数 $k$ ，当我们处理完所有大质数为 $k$ 的数字时，对于所有第 12 位为 1 的状态，因为后续的数都不包含 $k$ ，所以对答案一定不会产生贡献，把 $dp$ 数组 $[2^{11}, 2^{12})$ 的部分清空即可

复杂度 $O(2^{11} * n)$ 
#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

const int P = 1e9 + 7;
template<const int mod>
struct ModInt {
    static const int P = mod;
    int x;
    ModInt (int x = 0) : x(x % P) {}
    ModInt (LL x) : x(int(x % P)) {}
    int val() {return x;}

    ModInt operator + (const ModInt &a) const {int x0 = x + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    ModInt operator - (const ModInt &a) const {int x0 = x - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    ModInt operator * (const ModInt &a) const {return ModInt(1ll * x * a.x % P);}
    ModInt operator / (const ModInt &a) const {return *this * a.inv();}
    ModInt & operator ++ () {++x; return *this;}
    ModInt & operator -- () {--x; return *this;}
    bool operator == (const ModInt &a) const {return x == a.x;};
    bool operator != (const ModInt &a) const {return x != a.x;};
    void operator += (const ModInt &a) {x += a.x; if (x >= P) x -= P;}
    void operator -= (const ModInt &a) {x -= a.x; if (x < 0) x += P;}
    void operator *= (const ModInt &a) {x = 1ll * x * a.x % P;}
    void operator /= (const ModInt &a) {*this = *this / a;}
    friend ModInt operator + (int y, const ModInt &a){int x0 = y + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    friend ModInt operator - (int y, const ModInt &a){int x0 = y - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    friend ModInt operator * (int y, const ModInt &a){return ModInt(1ll * a.x * y % P);}
    friend ModInt operator / (int y, const ModInt &a){return ModInt(y) / a;}
    friend ostream &operator<<(ostream &os, const ModInt &a) {return os << (a.x + P) % P;}
    friend istream &operator>>(istream &is, ModInt &t) {return is >> t.x;}

    ModInt pow(LL n) const {
        ModInt sum(1), base(x);
        n %= (P - 1);
        while (n) {
            if (n & 1) sum *= base;
            base *= base;
            n >>= 1;
        }
        return sum;
    }

    ModInt inv() const {
        int a = x, b = P, x = 1, y = 0;
        while (b) {
            int t = a / b;
            a -= t * b; swap(a, b);
            x -= t * y; swap(x, y);
        }
        if (x < 0) y += P;
        return x;
    }
};
using mint = ModInt<P>;

const int maxn = 1e3 + 5;

int n;
int a[maxn];

int p[15], cnt;
void init(int x) {
    vector<int> v(x + 5, 0);
    for (int i = 2; i <= x; i++) {
        if (!v[i]) p[++cnt] = i;
        for (int j = 1; j <= cnt; j++) {
            if (p[j] * i > x) break;
            v[p[j] * i] = 1;
            if (i % p[j] == 0) break;
        }
    }
}

int main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    init(33);

    int mx = 0;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];

    vector<pair<int, int> > q[maxn];

    for (int i = 1; i <= n; i++) {
        mx = max(mx, a[i]);
        int v = 0, w = 1, tmp = a[i];
        for (int j = 1; j <= 11; j++) {
            int cnt = 1;
            while (tmp % p[j] == 0) {
                v ^= (1 << j - 1);
                tmp /= p[j];
                ++cnt;
                if (cnt & 1) w *= p[j];
            }
        }
        q[tmp].push_back({v + (tmp > 33) * (1 << 11), w});
    }

    vector<mint> dp(1 << 12, 0), lst(1 << 12, 0);

    int now = 0;
    lst[0] = 1;
    for (int i = 1; i <= mx; i++) {
        if (q[i].empty()) continue;
        p[12] = i;
        for (auto [v, w] : q[i]) {
            for (int j = 0; j < (1 << 12); j++) dp[j] = lst[j];
            for (int j = 0; j < (1 << 12); j++) {
                mint s = 1;
                for (int k = 1; k <= 12; k++)
                    if ((v & j) >> (k - 1) & 1) s *= p[k];
                dp[j ^ v] += lst[j] * w * s;
            }
            swap(lst, dp);
        }
        for (int j = (1 << 11); j <= (1 << 12); j++) lst[j] = 0;
    }

    cout << lst[0] - 1 << "\n";
    
    return 0;
}
```

### [I - Red Playing Cards](https://ac.nowcoder.com/acm/contest/81597/I)

一种另类的区间 dp

对于一个删除的区间，如果我们已经知道这个区间内的所有删除区间的答案贡献，就可以用 dp 扫一遍处理出这个区间的贡献，那么考虑按照区间长度排序后依次处理

最后塞一个边界为 $[0, n + 1]$ ，边界值为 $0$ 的区间再扫一遍即可

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
#define int long long
using namespace std;
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 3e3 + 5;

int n;
int a[maxn << 1];
struct node {
    int l, r, len;
}l[maxn];
int cnt;
int pos[maxn << 1], pre[maxn << 1];
pair<int, int> f[maxn << 1];
pair<int, int> dp[maxn << 1][3], mx[maxn << 1];

bool cmp(node x, node y) {
    if (x.len != y.len) return x.len < y.len;
    return x.l < y.l;
}
void calc(int l, int r, int st) {
    int len = r - l + 1;
    for (int i = l - 1; i <= r; i++) dp[i][0] = mx[i] = {len * st, 0}, dp[i][1] = {0, 0};

    for (int i = l + 1; i < r; i++) {
        if (dp[i - 1][0].first > dp[i - 1][1].first) dp[i][0] = dp[i - 1][0];
        if (dp[i - 1][0].first < dp[i - 1][1].first) dp[i][0] = dp[i - 1][1];
        if (dp[i - 1][0].first == dp[i - 1][1].first) {
            if (dp[i - 1][0].second < dp[i - 1][1].second) dp[i][0] = dp[i - 1][0];
                else dp[i][0] = dp[i - 1][1];
        }

        mx[i] = dp[i][0];
        if (pre[i] < l || a[i] < st) continue;

        int tmp = mx[pre[i] - 1].first + f[i].first - f[i].second * st;
        int num = mx[pre[i] - 1].second + f[i].second;
        dp[i][1].first = tmp, dp[i][1].second = num;
        
        if (dp[i][1].first > mx[i].first) mx[i] = dp[i][1];
    }
    f[r].first = mx[r - 1].first;
    f[r].second = len;

    return ;
}
signed main()
{
    n = read() * 2;

    for (int i = 1; i <= n; i++) a[i] = read();

    for (int i = 1; i <= n; i++) {
        if (!pos[a[i]]) {
            pos[a[i]] = i;
        } else {
            pre[i] = pos[a[i]];
            l[++cnt] = {pos[a[i]], i, i - pos[a[i]] + 1};
        }
    }
    sort(l + 1, l + 1 + cnt, cmp);

    for (int i = 1; i <= cnt; i++) {
        calc(l[i].l, l[i].r, a[l[i].l]);
    }

    pre[n + 1] = 0, a[n + 1] = 0;
    calc(0, n + 1, 0);

    printf("%lld\n", f[n + 1].first);

    return 0;
}
```

## 杭电多校 01 :

### [1001: 循环位移](https://acm.hdu.edu.cn/showproblem.php?pid=7433)

循环位移一般通过倍长解决，把 a 产生的 $n$ 个字符串的哈希值存到 `map` 里

再看 b 的所有连续子串哈希值是否在 `map` 里即可

时间复杂度 $O(nlogn)$

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 2.1e6 + 5;

int base[3] = {0, 131, 13131};
const LL P = 998244353;

LL inv(LL c) {
    LL a = c, b = P, x = 1, y = 0;
    while (b) {
        int t = a / b;
        a -= t * b; swap(a, b);
        x -= t * y; swap(x, y);
    }
    return (x % P + P) % P;
}
int invfact1[maxn], invfact2[maxn];
void init(int n) {
    invfact1[0] = invfact2[0] = 1;
    LL invbase1 = inv(base[1]), invbase2 = inv(base[2]);
    LL tmp1 = 1, tmp2 = 1;
    for (int i = 1; i <= n; i++) {
        invfact1[i] = tmp1 = tmp1 * invbase1 % P;
        invfact2[i] = tmp2 = tmp2 * invbase2 % P;
    }
}

template<const int mod>
struct String_Hash {
    static const int P = mod;
    int n;
    vector<LL> d1, d2;

    String_Hash () : n(0) {}
    String_Hash(char *s) {
        init(s);
    }
    void init(char *s) {
        n = strlen(s);
        d1.assign(n + 5, 0);
        d2.assign(n + 5, 0);
        LL p1 = 1, p2 = 1;
        for (int i = 1; i <= n; i++) {
            d1[i] = (d1[i - 1] + p1 * (*(s + i - 1) - 64) % P) % P;
            (p1 *= base[1]) %= P;
            d2[i] = (d2[i - 1] + p2 * (*(s + i - 1) - 64) % P) % P;
            (p2 *= base[2]) %= P;
        }
    }
    pair<LL, LL> gets(int l, int r) {
        LL s1, s2;
        s1 = (d1[r] - d1[l - 1]) * invfact1[l - 1] % P;
        s2 = (d2[r] - d2[l - 1]) * invfact2[l - 1] % P;
        (s1 += P) %= P, (s2 += P) %= P;
        return {s1, s2};
    }
};
using stringhash = String_Hash<P>;

int T;
char A[maxn], B[maxn];

int main()
{
    init(2.1e6);

    T = read();
    while (T--) {
        scanf("%s%s", A, B);

        int lena = strlen(A), lenb = strlen(B);
        for (int i = lena; i < lena * 2; i++) A[i] = A[i - lena];
        stringhash a(A), b(B);

        map<pair<LL, LL>, int> mp;
        for (int i = 1; i <= lena; i++) {
            int l = i, r = l + lena - 1;
            mp[a.gets(l, r)] = 1;
        }

        int ans = 0;
        for (int i = 1; i <= lenb - lena + 1; i++) {
            int l = i, r = l + lena - 1;
            if (mp[b.gets(l, r)]) ans++;
        }

        printf("%d\n", ans);
    }

    return 0;
}
```

### [1002: 星星](https://acm.hdu.edu.cn/showproblem.php?pid=7434)

签到 1

简单小 `dp`

$dp_{i, j}$ 表示前 $i$ 次操作获得 $j$ 颗星星的最小花费

可以用滚动数组优化掉一维
#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
#define int long long
using namespace std;
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 4e3 + 5;
const LL inf = 1e18;

int T;
int n, k;
int a[maxn][5];
LL dp[maxn][2];

signed main()
{
    T = read();
    while (T--) {
        n = read(); k = read();

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= 4; j++)
                a[i][j] = read();
        }
        
        vector<LL> lst(k + 5, inf), dp(k + 5, inf);

        lst[0] = dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= 4; j++) {
                for (int x = k; x >= j; x--)
                    dp[x] = min(dp[x], lst[x - j] + a[i][j]);
            }
            for (int j = 0; j <= k; j++) lst[j] = dp[j];
            swap(lst, dp);
        }
        printf("%lld\n", lst[k]);
    }

    return 0;
}
```

### [1003: 树](https://acm.hdu.edu.cn/showproblem.php?pid=7435)

假设当前的子树里有若干个数字，新插入一个数字 $x$ 时，若比它小的数字有 $num_{less}$ 个，比它大的数有 $num_{more}$ 个，与比它小的数字贡献为 $x * \sum (x - a_i) = num_{less} * x^2 - x * \sum a_i$ ，与比它大的数字贡献为 $\sum a_i*(a_i - x) = \sum {a_i}^2 - \sum (a_i * x)$ 

那么我们在树上启发式合并时，用树状数组维护一下当前数字的个数、和 和平方和，在向每个点插入轻子树节点的时候，就能算出轻子树之间的贡献以及轻子树和重子树之前的贡献，再加上重子树的贡献即可

题目要求的二元组无序，自己跟自己的贡献为 0，所以最终的 $ans_i$ 要乘 2

复杂度 $O(nlog^2n)$

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
#define int long long
using namespace std;
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

struct Fenwick {
    int n;
    vector<LL> t;
    Fenwick(int n) : n(n), t(n + 5, 0) {}
    int lowbit(int x) {return x & -x;}
    void add(int pos, LL y) {
        for (int i = pos; i <= n; i += lowbit(i)) t[i] += y;
    }
    void add(int l, int r, LL y) {
        add(l, y);
        if (r + 1 <= n) add(r + 1, -y);
    }
    LL query(int pos) {
        LL sum = 0;
        for (int i = pos; i; i -= lowbit(i)) sum += t[i];
        return sum;
    }
    LL query(int l, int r) {
        return query(r) - query(l - 1);
    }
};

const int maxn = 5e5 + 5;

int n;
int a[maxn], mx;
vector<int> G[maxn];

unsigned LL ans[maxn];
unsigned LL fin = 0;

Fenwick t(1e6), sum(1e6), sq(1e6);
vector<LL> st[maxn];

int siz[maxn], son[maxn], dep[maxn];
void dfs1(int cur, int ftr, int depth) {
    siz[cur] = 1, son[cur] = 0, dep[cur] = depth;
    for (auto v : G[cur])
        if (v != ftr) {
            dfs1(v, cur, depth + 1);
            siz[cur] += siz[v];
            if (siz[v] > siz[son[cur]]) son[cur] = v;
        }
}
void dfs2(int cur, int ftr, int kep) {
    for (auto v : G[cur]) {
        if (v != son[cur] && v != ftr) 
            dfs2(v, cur, 0);
    }
    if (son[cur]) dfs2(son[cur], cur, 1);

    if (!son[cur]) {
        st[cur].push_back(a[cur]);
        if (kep) t.add(a[cur], 1), sum.add(a[cur], a[cur]), sq.add(a[cur], a[cur] * a[cur]);
        return ;
    }

    st[cur].push_back(a[cur]);
    swap(st[cur], st[son[cur]]);
    
    for (auto v : G[cur]) {
        if (v == ftr) continue;
        for (auto x : st[v]) {
            ans[cur] += t.query(1, x - 1) * x * x - x * sum.query(1, x - 1);
            ans[cur] += sq.query(x + 1, mx) - 1ll * x * sum.query(x + 1, mx);

            t.add(x, 1), sum.add(x, x), sq.add(x, x * x);
            st[cur].push_back(x);
        }
        st[v].clear();
    }

    ans[cur] <<= 1;
    
    if (!kep) {
        for (auto v : st[cur]) {
            int num = 1;
            t.add(v, -num), sum.add(v, -v * num), sq.add(v, -v * v * num);
        }
    }
}
void dfs3(int cur, int ftr) {
    for (auto v : G[cur])
        if (v != ftr) {
            dfs3(v, cur);
        }
    ans[cur] += ans[son[cur]];
    fin ^= ans[cur];
}
signed main()
{
    n = read();
    for (int i = 1; i < n; i++) {
        int x, y;
        x = read(); y = read();
        G[x].push_back(y), G[y].push_back(x);
    }
    for (int i = 1; i <= n; i++) a[i] = read(), mx = max(mx, a[i]);

    dfs1(1, 0, 1);
    dfs2(1, 0, 1);
    dfs3(1, 0);

    cout << fin << "\n";

    return 0;
}
```

### [1004 - 传送](https://acm.hdu.edu.cn/showproblem.php?pid=7436)

线段树分治

因为并查集始终为树形结构，当增加某个节点的时间时，我们将修改放到这个联通树的根节点上

当添加边 $(u, v)$ 时，在此之前 u, v 不连通，所以相当于给整颗 $v$ 的联通树多增加了 $tag_{root_u}$ 的答案，要把 $tag_{root_v}$ 减去 $tag_{root_v}$ 

当删去边 $(u, v)$ 时，因为 $root_u$ 对 $root_v$ 的贡献还停留在 $root_u$ 上，要把这部分贡献加到 $root_v$ 上

遍历到叶子结点时，把 $tag_{root_1}$ 加上当前时刻，也就是增加了此时与 1 联通的所有点的值

最后将所有边删除得到的就是每个点的停留时间

这里用的是可撤销并查集，所以不能压缩路径，要按秩合并，回溯时按照加边顺序倒着删边

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 6e5 + 5;

int n, m;

LL ans[maxn], f[maxn], siz[maxn];
vector<pair<int, int> > st;
vector<pair<int, int> > t[maxn << 2];

int find(int x) {
    return f[x] == x ? x : find(f[x]);
}
void merge(int u, int v) {
    u = find(u), v = find(v);
    if (u == v) return ;
    if (siz[v] > siz[u]) swap(u, v);
    st.push_back({u, v});
    f[v] = u;
    siz[u] += siz[v];
    ans[v] -= ans[u];
}
void back(int num) {
    while (st.size() > num) {
        auto [u, v] = st[st.size() - 1];
        st.pop_back();
        siz[u] -= siz[v];
        ans[v] += ans[u];
        f[v] = v;
    }
}

void hang(int l, int r, int x, int y, int u, int v, int p) {
    if (x <= l && r <= y) {
        t[p].push_back({u, v});
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) hang(l, mid, x, y, u, v, p << 1);
    if (y > mid) hang(mid + 1, r, x, y, u, v, p << 1 | 1);
}

void dfs(int l, int r, int p) {
    int tmp = st.size();
    for (auto [u, v] : t[p]) {
        merge(u, v);
    }
    if (l == r) {
        ans[find(1)] += l;
        back(tmp);
        return ;
    }

    int mid = (l + r) >> 1;
    dfs(l, mid, p << 1);
    dfs(mid + 1, r, p << 1 | 1);
    back(tmp);
}
int main()
{
    n = read(); m = read();
    for (int i = 1; i <= m; i++) {
        int x, y, a, b;
        x = read(); y = read(); a = read(); b = read();
        hang(1, n, a, b, x, y, 1);
    }
    for (int i = 1; i <= n; i++) f[i] = i, siz[i] = 1;

    dfs(1, n, 1);
    back(0);

    LL fin = 0;
    for (int i = 1; i <= n; i++)
        fin ^= ans[i];
    printf("%lld\n", fin);

    return 0;
}
```
### [1005 - 博弈](https://acm.hdu.edu.cn/showproblem.php?pid=7437)

考虑两种情况

$n$ 为偶数时，设平局的概率为 $p$ 

当不平局时，两人决策反转胜负交换，所以 A 获胜概率为 $\frac{1 - p}{2}$ 

考虑如何计算平局概率，当所有字母的出现次数均为偶数，则 A 每次选完一个字母 B 都要选择相同的字母，所以 A 最终选了哪些字母是确定的，设一共有 $tot$ 个字母，则 A 需要选 $\frac{tot}{2}$ 个，先考虑这$\frac{tot}{2}$ 个数字的顺序，相同字母视为相同；再考虑每个字母的排列顺序，就是每个数的个数的全排列数，最后除掉全部情况 $\prod_{i = 1}^{tot}i$ 就是平局概率

当出现奇数次数的字母时，不可能平局， $p = 0$

$n$ 为奇数时，设选出前 $n - 1$ 个数时平局的概率为 $p$ 

因为 A 多选一个数，所以获胜概率为 $\frac{1 + p}{2}$

如何计算平局概率跟上面大致相同，唯一的区别是多出现一次的那个字母相当于 $x$ 个里选 $x - 1$ 的排列，应该是 $\prod_{i = 2}^{x}i$ （虽说从结果上看没区别

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

const int P = 998244353;
template<const int mod>
struct ModInt {
    static const int P = mod;
    int x;
    ModInt (int x = 0) : x(x % P) {}
    ModInt (LL x) : x(int(x % P)) {}
    int val() {return x;}

    ModInt operator + (const ModInt &a) const {int x0 = x + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    ModInt operator - (const ModInt &a) const {int x0 = x - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    ModInt operator * (const ModInt &a) const {return ModInt(1ll * x * a.x % P);}
    ModInt operator / (const ModInt &a) const {return *this * a.inv();}
    ModInt & operator ++ () {++x; return *this;}
    ModInt & operator -- () {--x; return *this;}
    bool operator == (const ModInt &a) const {return x == a.x;};
    bool operator != (const ModInt &a) const {return x != a.x;};
    void operator += (const ModInt &a) {x += a.x; if (x >= P) x -= P;}
    void operator -= (const ModInt &a) {x -= a.x; if (x < 0) x += P;}
    void operator *= (const ModInt &a) {x = 1ll * x * a.x % P;}
    void operator /= (const ModInt &a) {*this = *this / a;}
    friend ModInt operator + (int y, const ModInt &a){int x0 = y + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    friend ModInt operator - (int y, const ModInt &a){int x0 = y - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    friend ModInt operator * (int y, const ModInt &a){return ModInt(1ll * a.x * y % P);}
    friend ModInt operator / (int y, const ModInt &a){return ModInt(y) / a;}
    friend ostream &operator<<(ostream &os, const ModInt &a) {return os << (a.x + P) % P;}
    friend istream &operator>>(istream &is, ModInt &t) {return is >> t.x;}

    ModInt pow(LL n) const {
       ModInt sum(1), base(x);
       n %= (P - 1);
       while (n) {
           if (n & 1) sum *= base;
           base *= base;
           n >>= 1;
       }
       return sum;
    }

    ModInt inv() const {
        int a = x, b = P, x = 1, y = 0;
        while (b) {
        int t = a / b;
           a -= t * b; swap(a, b);
           x -= t * y; swap(x, y);
        }
        if (x < 0) y += P;
        return x;
    }
};
using mint = ModInt<P>;

const int maxn = 1e7 + 5;
mint fact[maxn], invfact[maxn];

void init(int n) {
    fact[0] = invfact[0] = 1;
    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;
    
    invfact[n] = fact[n].inv();
    for (int i = n - 1; i; i--)
        invfact[i] = invfact[i + 1] * (i + 1);
}
mint C(int a, int b) {
    if (a == b || !b) return 1;
    if (a < b) return 0;
    return fact[a] * invfact[b] * invfact[a - b];
}
mint N(int a, int b) {
    if (!a) return 1;
    if (a == b) return fact[a];
    return fact[a] * fact[a - b].inv();
}

int T;
int n;
char ch[5];

int main()
{
    init(1e7);

    cin >> T;
    while (T--) {
        int tot = 0;
        
        vector<int> a(30, 0);
        cin >> n;
        for (int i = 1; i <= n; i++) {
            scanf("%s", ch);
            cin >> a[i];
            tot += a[i];
        }
        
        mint ans = 0;
        if (tot % 2 == 0) {
            int ff = 1;
            for (int i = 1; i <= n; i++)
                if (a[i] & 1) {ff = 0; break;}

            if (!ff) {
                ans = (mint)1 / 2;
            } else {
                mint p = 1;

                int tmp = tot / 2;
                for (int i = 1; i <= n; i++)
                    if (a[i]) {
                        p *= C(tmp, a[i] / 2), tmp -= a[i] / 2;
                        p *= N(a[i], a[i]);
                    }
                p /= N(tot, tot);
                ans = (1 - p) / 2;
            }
        } else {
            int cnt = 0;
            for (int i = 1; i <= n; i++)
                if (a[i] & 1) cnt++;

            if (cnt == 1) {
                mint p = 1;
                int tmp = tot / 2;
                for (int i = 1; i <= 26; i++) {
                    if (a[i]) {
                        p *= C(tmp, a[i] / 2), tmp -= a[i] / 2;
                        if (a[i] & 1) p *= N(a[i], a[i] - 1);
                            else p *= N(a[i], a[i]);
                    }
                }
                p /= N(tot, tot - 1);
                ans = (1 + p) / 2;
            } else {
                ans = (mint)1 / 2;
            }
        }
        
        cout << ans << "\n";
    }

    return 0;
}
```

### [1006 - 序列立方](https://acm.hdu.edu.cn/showproblem.php?pid=7438)

题目等效于选三个数值相同的序列的方案数

令 $dp{i, j, k}$ 表示三个序列分别以 $a_i, a_j, a_k$ 结尾的方案数，用三维前缀和就能转移了

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

const int P = 998244353;
template<const int mod>
struct ModInt {
    static const int P = mod;
    int x;
    ModInt (int x = 0) : x(x % P) {}
    ModInt (LL x) : x(int(x % P)) {}
    int val() {return x;}

    ModInt operator + (const ModInt &a) const {int x0 = x + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    ModInt operator - (const ModInt &a) const {int x0 = x - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    ModInt operator * (const ModInt &a) const {return ModInt(1ll * x * a.x % P);}
    ModInt operator / (const ModInt &a) const {return *this * a.inv();}
    ModInt & operator ++ () {++x; return *this;}
    ModInt & operator -- () {--x; return *this;}
    bool operator == (const ModInt &a) const {return x == a.x;};
    bool operator != (const ModInt &a) const {return x != a.x;};
    void operator += (const ModInt &a) {x += a.x; if (x >= P) x -= P;}
    void operator -= (const ModInt &a) {x -= a.x; if (x < 0) x += P;}
    void operator *= (const ModInt &a) {x = 1ll * x * a.x % P;}
    void operator /= (const ModInt &a) {*this = *this / a;}
    friend ModInt operator + (int y, const ModInt &a){int x0 = y + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    friend ModInt operator - (int y, const ModInt &a){int x0 = y - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    friend ModInt operator * (int y, const ModInt &a){return ModInt(1ll * a.x * y % P);}
    friend ModInt operator / (int y, const ModInt &a){return ModInt(y) / a;}
    friend ostream &operator<<(ostream &os, const ModInt &a) {return os << (a.x + P) % P;}
    friend istream &operator>>(istream &is, ModInt &t) {return is >> t.x;}

    ModInt pow(LL n) const {
       ModInt sum(1), base(x);
       n %= (P - 1);
       while (n) {
           if (n & 1) sum *= base;
           base *= base;
           n >>= 1;
       }
       return sum;
    }

    ModInt inv() const {
        int a = x, b = P, x = 1, y = 0;
        while (b) {
        int t = a / b;
           a -= t * b; swap(a, b);
           x -= t * y; swap(x, y);
        }
        if (x < 0) y += P;
        return x;
    }
};
using mint = ModInt<P>;

const int maxn = 2.5e2 + 5;

int n;
int a[maxn];
mint dp[maxn][maxn][maxn];
mint s[4][maxn][maxn][maxn];

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++)
            for (int k = 1; k <= n; k++) {
                if (a[i] == a[j] && a[i] == a[k]) dp[i][j][k] += s[3][i - 1][j - 1][k - 1] + 1;
                s[1][i][j][k] = s[1][i - 1][j][k] + dp[i][j][k];
                s[2][i][j][k] = s[2][i][j - 1][k] + s[1][i][j][k];
                s[3][i][j][k] = s[3][i][j][k - 1] + s[2][i][j][k];
            }
    }
    printf("%lld\n", s[3][n][n][n]);

    return 0;
}
```

### [1008 - 位运算](https://acm.hdu.edu.cn/showproblem.php?pid=7440)

签到 2

每一位的贡献是单独的

考虑 abcd 的一共16 种情况，有 12 种结果为 1，4 种结果为 0

按位数乘起来就行了

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

int T;
LL n, k;

int main()
{
    T = read();
    while (T--) {
        n = read(); k = read();

        LL ans = 1;
        for (int i = 0; i < k; i++) {
            if (n >> i & 1) ans *= 12;
                else ans *= 4;
        }
        printf("%lld\n", ans);
    }

    return 0;
}
```

### [1010 - 众数](https://acm.hdu.edu.cn/showproblem.php?pid=7442)

先用 st表 处理出区间最小值和它的位置

然后用堆挑出最大数所在的区间，假设为 $[l, r]$ ，这个数的贡献就是 $(r - i + 1) * (i - l + 1)$，然后再把区间拆成 $[l, i - 1]$ 和 $[i + 1, r]$ 两部分塞回堆里

因为数据随机生成，最终的答案一定是一个从大到小排比较靠前的数字，设定一个较小的数字，连拆这么多个区间后直接输出当前最大次数对应的树即可

---

抽象题目（

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 2e5 + 5;

int T;
int n, Q;
int a[maxn];

int lg[maxn];
pair<int, int> f[maxn][30];

void init(int n) {
    lg[1] = 0;
    for (int i = 2; i <= n; i++)
        lg[i] = lg[i >> 1] + 1;
    for (int i = 1; i <= n; i++) f[i][0] = {a[i], i};
    for (int j = 1; j <= lg[n]; j++)
        for (int i = 1; i <= n - (1 << j) + 1; i++) 
            if (f[i][j - 1].first > f[i + (1 << (j - 1))][j - 1].first) f[i][j] = f[i][j - 1];
                else f[i][j] = f[i + (1 << (j - 1))][j - 1];
}

pair<int, int> query(int l, int r) {
    int x = lg[r - l + 1];
    if (f[l][x].first > f[r - (1 << x) + 1][x].first) return f[l][x];
        else return f[r - (1 << x) + 1][x];
}

struct node {
    int l, r;
    pair<int, int> mx;
};
bool operator < (node x, node y) {
    return x.mx.first < y.mx.first;
}

int main()
{
    T = read();
    while (T--) {
        n = read(); Q = read();
        for (int i = 1; i <= n; i++) a[i] = read();

        init(n);

        LL fin = 0;
        for (int i = 1; i <= Q; i++) {
            int x, y;
            x = read(); y = read();

            LL ans = 0, anscnt = 0, now = 0, cnt = 0;

            priority_queue<node> q;
            q.push({x, y, query(x, y)});

            int check = 0;
            while (!q.empty()) {
                auto [l, r, mx] = q.top();
                q.pop();

                if (mx.first != now) now = mx.first, cnt = 0;
                cnt += 1ll * (mx.second - l + 1) * (r - mx.second + 1);

                if (cnt > anscnt) ans = now, anscnt = cnt;

                if (mx.second != l) q.push({l, mx.second - 1, {query(l, mx.second - 1)}});
                if (mx.second != r) q.push({mx.second + 1, r, {query(mx.second + 1, r)}});
                check++;
                if (check >= 30) break;
            }
            fin ^= 1ll * i * ans;
        }
        printf("%lld\n", fin);
    }

    return 0;
}
```


###  [1012 - 并](https://acm.hdu.edu.cn/showproblem.php?pid=7444)

首先可以发现一个格子对答案产生的贡献仅与它被多少个矩形覆盖有关

假设一个格子被 $k$ 个矩形覆盖，最终选到它的概率为 

$$\frac {1 - \binom{n - k}{k}}{\binom{n}{k}}$$
先对矩形离散化，再用二维前缀和就可以统计出有多少个格子被 $i$ 个矩形覆盖

最终答案为 $$\sum_{i = 1}^{n} (g_i * \frac{1 - \binom{n - k} {k}} {\binom{n} {k}})$$
#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

const int P = 998244353;
template<const int mod>
struct ModInt {
    static const int P = mod;
    int x;
    ModInt (int x = 0) : x(x % P) {}
    ModInt (LL x) : x(int(x % P)) {}
    int val() {return x;}

    ModInt operator + (const ModInt &a) const {int x0 = x + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    ModInt operator - (const ModInt &a) const {int x0 = x - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    ModInt operator * (const ModInt &a) const {return ModInt(1ll * x * a.x % P);}
    ModInt operator / (const ModInt &a) const {return *this * a.inv();}
    ModInt & operator ++ () {++x; return *this;}
    ModInt & operator -- () {--x; return *this;}
    bool operator == (const ModInt &a) const {return x == a.x;};
    bool operator != (const ModInt &a) const {return x != a.x;};
    void operator += (const ModInt &a) {x += a.x; if (x >= P) x -= P;}
    void operator -= (const ModInt &a) {x -= a.x; if (x < 0) x += P;}
    void operator *= (const ModInt &a) {x = 1ll * x * a.x % P;}
    void operator /= (const ModInt &a) {*this = *this / a;}
    friend ModInt operator + (int y, const ModInt &a){int x0 = y + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    friend ModInt operator - (int y, const ModInt &a){int x0 = y - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    friend ModInt operator * (int y, const ModInt &a){return ModInt(1ll * a.x * y % P);}
    friend ModInt operator / (int y, const ModInt &a){return ModInt(y) / a;}
    friend ostream &operator<<(ostream &os, const ModInt &a) {return os << (a.x + P) % P;}
    friend istream &operator>>(istream &is, ModInt &t) {return is >> t.x;}

    ModInt pow(LL n) const {
       ModInt sum(1), base(x);
       n %= (P - 1);
       while (n) {
           if (n & 1) sum *= base;
           base *= base;
           n >>= 1;
       }
       return sum;
    }

    ModInt inv() const {
        int a = x, b = P, x = 1, y = 0;
        while (b) {
        int t = a / b;
           a -= t * b; swap(a, b);
           x -= t * y; swap(x, y);
        }
        if (x < 0) y += P;
        return x;
    }
};
using mint = ModInt<P>;

const int maxm = 1e4 + 5;
mint fact[maxm], invfact[maxm];

void init(int n) {
    fact[0] = invfact[0] = 1;
    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;
    
    invfact[n] = fact[n].inv();
    for (int i = n - 1; i; i--)
        invfact[i] = invfact[i + 1] * (i + 1);
}
mint C(int a, int b) {
    if (a == b || !b) return 1;
    if (a < b) return 0;
    return fact[a] * invfact[b] * invfact[a - b];
}

const int maxn = 2e3 + 5;

int n;
struct node {
    int xl, xr, yl, yr;
}a[maxn];
int s[maxn << 1][maxn << 1];
int main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    init(1e4);

    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].xl >> a[i].yl >> a[i].xr >> a[i].yr;
    }

    map<int, int> mpx, mpy;
    vector<mint> posx(maxn << 1, 0), posy(maxn << 1, 0);
    vector<int> p;

    int mxx = 0, mxy = 0;
    for (int i = 1; i <= n; i++) p.push_back(a[i].xl), p.push_back(a[i].xr);
    sort(p.begin(), p.end());
    int cnt = 0;
    for (int i = 0; i < p.size(); i++) {
        if (!i || p[i] != p[i - 1]) {
            ++cnt;
            mpx[p[i]] = cnt;
            posx[cnt] = p[i];
        }
    }
    mxx = cnt;
    posx[cnt + 1] = p[p.size() - 1] + 1;
    for (int i = 1; i <= n; i++) a[i].xl = mpx[a[i].xl], a[i].xr = mpx[a[i].xr];

    p.clear();
    for (int i = 1; i <= n; i++) p.push_back(a[i].yl), p.push_back(a[i].yr);
    sort(p.begin(), p.end());
    cnt = 0;
    for (int i = 0; i < p.size(); i++) {
        if (!i || p[i] != p[i - 1]) {
            ++cnt;
            mpy[p[i]] = cnt;
            posy[cnt] = p[i];
        }
    }
    mxy = cnt;
    posy[cnt + 1] = p[p.size() - 1] + 1;
    for (int i = 1; i <= n; i++) a[i].yl = mpy[a[i].yl], a[i].yr = mpy[a[i].yr];

    vector<vector<int> > s(mxx + 5, vector<int> (mxy + 5, 0));

    for (int i = 1; i <= n; i++) {
        s[a[i].xl + 1][a[i].yl + 1]++;
        s[a[i].xl + 1][a[i].yr + 1]--;
        s[a[i].xr + 1][a[i].yl + 1]--;
        s[a[i].xr + 1][a[i].yr + 1]++;
    }
    
    for (int i = 1; i <= mxx; i++)
        for (int j = 1; j <= mxy; j++)
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];

    vector<mint> g(n + 5, 0);
    for (int i = 2; i <= mxx; i++)
        for (int j = 2; j <= mxy; j++) {
            mint num = 0;
            num = (posx[i] - posx[i - 1]) * (posy[j] - posy[j - 1]);
            g[s[i][j]] += num;
        }

    mint tot = 0;
    for (int i = 1; i <= n; i++) tot += g[i];
    for (int k = 1; k <= n; k++) {
        mint ans = 0;
        for (int i = 1; i <= n; i++)
            ans -= C(n - i, k) * g[i];
        cout << ans / C(n, k) + tot << "\n";
    } // 要在外面除，求inv会多个log

    return 0;
}
```