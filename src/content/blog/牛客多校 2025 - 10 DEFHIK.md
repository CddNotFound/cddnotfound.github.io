---
title: '牛客多校 2025 - 10 DEFHIK'
description: ''
publishDate: 2025-08-14
tags:
  - ACM
  - 多校
---
<!-- more -->

感觉自己好菜

## [D - Grammar Test (grammar)](https://ac.nowcoder.com/acm/contest/108307/D)

签到 1

交换实际上就是互相异或三次，并且不能存在自己异或自己

所以最终的答案一定是一个 0101 或者 1010 串

判断以下长度时候是否满足奇数次交换，满足就是 2 ，不满足就是 0

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        
        if (n % 3 != 1 || (n / 3) % 2 == 0) {
            cout << "0\n";
            continue;
        }

        cout << "2\n";
    }

    return 0;
}
```

## [E - Sensei and Affection (affection)](https://ac.nowcoder.com/acm/contest/108307/E)

首先考虑 $m = 1$ 的情况，最终的高度一定是最大值，假设前一位需要需要增加 $x$ ，那么这一位至少可以"免费"增加 $x$ ，代价就是 $max \left(a_{i - 1} - a_i \right)$ ，所以最终答案为 $mx - a_1 + \sum_{i = 2}^{n}max \left( 0, a_{i - 1} - a_i \right)$

当 $m = 2$ 时，令 $dp_{i, 0/1}$ 表示让前 $i$ 位学生的好感度满足要求，且第 $i$ 位的好感值处于较大的或者较小的好感值所需的最小天数

此时较高的好感度有可能会超过最大值，因为 $a_i$ 的范围很小，考虑枚举这两个好感度，假设前一位离目标值差了 $x$ ，这一位离目标好感度差了 $y$ ，代价就是 $max \left(0, x - y \right)$ ，根据不同好感度 $x, y$ 不同，分类讨论一下即可

时间复杂度 $O(max\{a_i\}^2n)$

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    cin >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;
        vector<int> a(n + 5, 0);
        int mx = 0, mn = inf64;
        for (int i = 1; i <= n; i++) cin >> a[i], mx = max(a[i], mx), mn = min(a[i], mn);

        int ans = 0;
        ans = mx - a[1];
        for (int i = 2; i <= n; i++) ans += max(0ll, a[i - 1] - a[i]);

        if (m >= 2) {
            for (int high = mx; high <= 201; high++) {
                for (int low = mn; low <= high; low++) {
                    vector<array<int, 3>> dp(n + 5);
                    if (a[1] > low) {
                        dp[1][0] = inf32;
                        dp[1][1] = high - a[1];
                    } else {
                        dp[1][0] = low - a[1];
                        dp[1][1] = high - a[1];
                    }
                    for (int i = 2; i <= n; i++) {
                        if (a[i] > low) {
                            dp[i][0] = inf32;
                            dp[i][1] = min(dp[i - 1][0] + max(0ll, (high - a[i]) - (low - a[i - 1])), dp[i - 1][1] + max(0ll, a[i - 1] - a[i]));
                        } else {
                            dp[i][0] = min(dp[i - 1][0] + max(0ll, a[i - 1] - a[i]), dp[i - 1][1] + max(0ll, (low - a[i]) - (high - a[i - 1])));
                            dp[i][1] = min(dp[i - 1][0] + max(0ll, (high - a[i]) - (low - a[i - 1])), dp[i - 1][1] + max(0ll, a[i - 1] - a[i]));
                        }
                    }

                    ans = min({ans, dp[n][0], dp[n][1]});
                }
            }
        }

        cout << ans << "\n";
    }

    return 0;
}
```

## [F - Sensei and Yuuka Going Shopping (yuuka)](https://ac.nowcoder.com/acm/contest/108307/F)

首先枚举第一部分的范围，令 $lst_i$ 表示 $i$ 出现的最后一个位置， $nxt_i$ 表示在 $i$ 之后 $a_i$ 出现的下一个位置。

当第一部分包含某个数 $x$ 时，$b_2$ 的范围在 $[nxt_i + 1, lst_i]$ 时，$x$ 会对答案产生贡献，用线段树维护即可

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

const int maxn = 1.5e5 + 5;

int t[maxn << 2], lazy[maxn << 2], pos[maxn << 2];

void pushup(int p) {
    if (t[p << 1] > t[p << 1 | 1]) {
        t[p] = t[p << 1];
        pos[p] = pos[p << 1];
    } else {
        t[p] = t[p << 1 | 1];
        pos[p] = pos[p << 1 | 1];
    }
}
void pushdown(int l, int r, int p) {
    if (lazy[p]) {
        int ls = p << 1, rs = p << 1 | 1, k = lazy[p];
        lazy[ls] += k, lazy[rs] += k;
        t[ls] += k, t[rs] += k;
        lazy[p] = 0;
    }
}
void build(int l, int r, int p) {
    t[p] = lazy[p] = 0, pos[p] = l;
    if (l == r) return ;
    int mid = (l + r) >> 1;
    build(l, mid, p << 1);
    build(mid + 1, r, p << 1 | 1);
    pushup(p);
}
void update(int l, int r, int x, int y, int k, int p) {
    if (x <= l && r <= y) {
        lazy[p] += k;
        t[p] += k;
        return ;
    }
    pushdown(l, r, p);
    int mid = (l + r) >> 1;
    if (x <= mid) update(l, mid, x, y, k, p << 1);
    if (y > mid) update(mid + 1, r, x, y, k, p << 1 | 1);
    pushup(p);
}
pii query(int l, int r, int x, int y, int p) {
    if (x <= l && r <= y) {
        return {t[p], pos[p]};
    }
    pushdown(l, r, p);
    int res = -inf64, mid = (l + r) >> 1, pos = 0;
    if (x <= mid) {
        pii tmp = query(l, mid, x, y, p << 1);
        if (tmp.first > res) {
            res = tmp.first;
            pos = tmp.second;
        }
    }
    if (y > mid) {
        pii tmp = query(mid + 1, r, x, y, p << 1 | 1);
        if (tmp.first > res) {
            res = tmp.first;
            pos = tmp.second;
        }
    }
    pushup(p);
    return {res, pos};
}

const int maxm = 1e6 + 6;
int lst[maxm], lstTag[maxm], lstId = 0;
int havTag[maxm], havId = 0;

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        vector<int> a(n + 5, 0);
        for (int i = 1; i <= n; i++) cin >> a[i];

        vector<int> nxt(n + 5, 0);
        ++lstId;
        for (int i = n; i; i--) {
            if (lstTag[a[i]] == lstId) nxt[i] = lst[a[i]];
            lst[a[i]] = i, lstTag[a[i]] = lstId;
            lst[a[i]] = i;
        }
        for (int i = 1; i <= n; i++) lst[a[i]] = i;

        int p1 = 2, p2 = 3;
        build(1, n, 1);

        ++havId;
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            int x = a[i];
            if (havTag[x] != havId) {
                havTag[x] = havId;
                if (lst[x] != nxt[i]) {
                    update(1, n, nxt[i] + 1, lst[x], 1, 1);
                }
            } else {
                if (i + 1 <= nxt[i]) update(1, n, i + 1, nxt[i], -1, 1);
            }

            pii tmp = query(1, n, i + 1, n, 1);
            if (tmp.first > ans) {
                ans = tmp.first;
                p1 = i + 1, p2 = tmp.second;
            }
        }

        cout << ans << "\n";
        cout << p1 << ' ' << p2 << "\n";
    }

    return 0;
}
```

## [H - Rev Equation (NOI-tAUqe ver.) (equation)](https://ac.nowcoder.com/acm/contest/108307/H)

签到 2

根据样例，当两个数字相等的时候最终的回文串只有 $=x*x=$ 这一种形式（中间的符号任意），所以一定不合法

其他情况一定是添加三个字符，加法和乘法满足交换律，一定合法

对于减法，只有当 $s_0 = 0$ 的时候，可以将等式变成 $0 = x - x = 0$ 的形式，才是合法的。

对于 $x = y$ 的减法符合第一种情况，$x - y = y - x$ 这种形式是不被考虑的

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    cin >> T;
    while (T--) {
        string str;
        cin >> str;
        str = " " + str;

        if (str[1] == str[3]) {
            cout << "No\n";
            continue;
        }

        if (!(str[2] == '-')) {
            cout << "Yes\n";
            continue;
        }

        if (str[1] == '0') {
            cout << "Yes\n";
        } else {
            cout << "No\n";   
        }
    }

    return 0;
}
```

## [I - Matrix (matrix)](https://ac.nowcoder.com/acm/contest/108307/I)

这题24沈阳站既视感太强了，结论一眼看出来了（

先说结论，当且仅当 $gcd(n, m) = 1$ 时有解

若 $n, m$ 不互质，当填到 $\frac{nm}{g}$ 时，下一个数的坐标还在原位，无法填满

然后我们将每 $m$ 个数分成一组，每一组移动的距离都是 $1, 2, 3, ... , m - 1$ ，左右横跳即可填满一行

当填完一行时进行行的移动，同理也是上下横跳，此时相对于第一行的移动距离在模 $n$ 意义下相当于为 $\{0, m, (n - 1)m, 2m, (n - 2)m, 3m, (n - 3)m, ...\}$ ，由于 $n, m$ 互质，所以一定不会重复

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

int gcd(int a, int b) {
    return !b ? a : gcd(b, a % b);
}

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    // cin >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;

        if (gcd(n, m) != 1) {
            cout << "NO\n";
            continue;
        }

        vector<vector<int>> ans(n + 5, vector<int>(m + 5, 0));
        ans[0][0] = 1;
        int colway = 1, rowway = 1;
        int x = 0, y = 0;
        for (int i = 2; i <= n * m; i++) {
            if (i % m == 1 || m == 1) {
                x = ((x + rowway * (i - 1)) % n + n) % n;
                rowway *= -1;
            } else {
                y = ((y + colway * (i - 1)) % m + m) % m;
                colway *= -1;
            }
            ans[x][y] = i;
        }

        cout << "YES\n";
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++)
                cout << ans[i][j] << ' ';
            cout << "\n";
        }

    }

    return 0;
}
```

## [K - Amazing Sets (amazing)](https://ac.nowcoder.com/acm/contest/108307/K)

首先进行一个缩点，然后问题就转换为了从新的树中选择若干个子树，有多少个不同的权值和（重复部分只记一次）

令 $dp_{i, j}$ 表示在以 $i$ 为根的子树中，是否能选出 $j$ 的权值，在树上直接暴力跑背包即可，合并子树后还需要加入整个子树的权值。

p.s. $dp$ 数组需要开 `bool` ，否则会爆空间

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

const int maxn = 1e4 + 5;

bool dp[maxn][maxn];

struct SCC {
    int n;
    vector<vector<int>> G;
    vector<int> dfn, low, ins, stk;
    vector<int> col;
    int id, colcnt;

    SCC() {}
    SCC(int x) {
        init(x);
    }
    void init(int x) {
        n = x;
        G.assign(n + 5, {});
    }
    void add_edge(int x, int y) {
        G[x].push_back(y);
    }
    void dfs(int cur) {
        dfn[cur] = low[cur] = ++id;
        stk.push_back(cur), ins[cur] = 1;
        for (auto v : G[cur]) {
            if (!dfn[v]) {
                dfs(v);
                low[cur] = min(low[cur], low[v]);
            } else if (ins[v]) {
                low[cur] = min(low[cur], dfn[v]);
            }
        }
        
        if (dfn[cur] == low[cur]) {
            ++colcnt;
            int x = stk.back();
            while (x != cur) {
                col[x] = colcnt;
                ins[x] = 0;
                stk.pop_back();
                x = stk.back();
            }
            col[cur] = colcnt;
            ins[cur] = 0;
            stk.pop_back();
        }
    }
    void gets() {
        dfn.assign(n + 5, 0);
        low.assign(n + 5, 0);
        ins.assign(n + 5, 0);
        col.assign(n + 5, 0);
        stk.clear();
        id = colcnt = 0;

        for (int i = 1; i <= n; i++)
            if (!dfn[i]) dfs(i);
    }
    int diff(int x, int y) {
		return col[x] != col[y];
	}
};

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    // cin >> T;
    while (T--) {
        int n, m;
        cin >> n;
        vector<int> a(n + 5, 0), in(n + 5, 0);
        SCC G(n);
        vector<pii> e;
        for (int i = 1; i <= n; i++) cin >> a[i];
        for (int i = 1; i < n; i++) {
            int x, y;
            cin >> x >> y;
            G.add_edge(x, y);
            e.push_back({x, y});
            ++in[y];
        }
        cin >> m;
        for (int i = 1; i <= m; i++) {
            int x, y;
            cin >> x >> y;
            e.push_back({x, y});
            G.add_edge(x, y);
        }
        int root = 0;
        for (int i = 1; i <= n; i++)
            if (!in[i]) {root = i; break;}

        G.gets();

        vector<vector<int>> TG(G.colcnt + 5);
        vector<int> val(G.colcnt + 5, 0);
        for (int i = 1; i <= n; i++) val[G.col[i]] += a[i];
        set<pii> st;
        for (auto [x, y] : e) {
            x = G.col[x], y = G.col[y];
            if (x == y || st.count({x, y})) continue;
            st.insert({x, y});
            TG[x].push_back(y);
        }
        root = G.col[root];

        // vector<vector<int>> dp(G.colcnt + 5, vector<int>(10005, 0));
        vector<int> siz(G.colcnt + 5, 0);
        for (int i = 1; i <= G.colcnt; i++) dp[i][0] = 1;
        function<void(int, int)> dfs = [&] (int cur, int ftr) -> void {
            siz[cur] = val[cur];
            for (auto v : TG[cur]) {
                if (v == ftr) continue;
                dfs(v, cur);
                siz[cur] += siz[v];
                for (int x = siz[cur]; x >= 0; x--) {
                    if (!dp[cur][x]) continue;
                    for (int y = siz[v]; y >= 0; y--) {
                        if (!dp[v][y]) continue;
                        dp[cur][x + y] = 1;
                    }
                }
            }
            
            dp[cur][siz[cur]] = 1;
        };
        dfs(root, 0);
        

        int ans = 0;
        for (int i = 0; i <= 10000; i++)
            ans += dp[root][i];
        cout << ans << "\n";
        // cout << stk[root].size() << "\n";
    }

    return 0;
}
```