---
title: 'CCPC 山东邀请赛 2024'
description: ''
publishDate: 2024-05-26
tags:
  - ACM
  - 多校
  - 正赛
  - 游记
---

<!-- more -->

## 游记

### Preface

济南好凉快，喜欢这个温度

### Day -1

下午到的济南，然后是去酒店、吃晚饭，还去附近的麦门买了俩麦旋风。

回酒店打会游戏就睡觉了

### Day 0

早上在写雅思听力，晚上在写大物作业，怎么会事呢（

山大好排面，好大的会展中心，人也好多，四点的时候排队签到还有好多人

一开始显示器角度不对，稍微用点力发现拧不过来，问完志愿者发现就是大力出奇迹，离谱捏

电脑也挺古董的，i5-5300U + 8G，编译一个万能头要十秒，光OMS就占了50%的CPU，不过还好第二天正赛的时候没这么卡，处于一个能用的状态。

热身赛象征性地签了一下 `A` ，然后 `B` 一眼暴力不想写， `C` 惊现校赛原题， `D` 是去年原题，于是就有正当理由摸鱼了（

但是感觉 `OMS` 用起来好难受，据说明年不用了，好耶

签完到就回酒店了，晚上去了附近的城南往事，炫了大半条黄金鲤鱼（调的太甜了受不了，主要是脆脆的口感好。

还买了dq 。冰淇淋，爽！

### Day 1

晚上睡的有点晚，醒的时候都 7:50 了。虽然理论上赶得上，但是因为把开幕式时间记成 8:20 就继续睡觉了，最后在 9:10 到的考场

但是依旧很困，中间写完那个最小生成树眼睛又干又涩直接进入注意力涣散状态（

最后半小时写 M 也没写完，评价是珍爱生命，远离海伦公式。（要是想起来有叉乘就能过 9 题差不多rk10了

记得开赛前xgg比赛前瞄到气球区 `ABD` 的气球特别多，于是开场策略变成 `ABD` 一人一题

结果是 D 开局 T 掉， A mid 没开 long long + check 没注意爆 long long 连 WA 两次，B 据说有思路但是找不到板子（悲

晚上去了ktv，但是 声音不好听+社恐属性 导致在沙发上瘫了三个小时一首没唱，我也是怪搞笑的（

## 题解


### [A - Printer](https://codeforces.com/gym/526653/problem/A)

二分

注意 check 函数里面计算 s 的时候可能会爆 `long long` ，要及时退出

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn = 1e2 + 5;
int T;
int n, k;
LL t[maxn], l[maxn], w[maxn];
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}
LL check(LL x) {
    LL s = 0;
    for (int i = 1; i <= n; i++) {
        LL num = t[i] * l[i] + w[i];
        s += x / num * l[i] + min(x % num / t[i], l[i]);
        if (s >= k) return 1;
    }
    return s >= k;
}
int main()
{
    T = read();
    while (T--) {
        n = read(); k = read();
        for (int i = 1; i <= n; i++) t[i] = read(), l[i] = read(), w[i] = read();

        LL l = 1, r = 2e18, tag = 0;
        while (l <= r) {
            LL mid = (l + r) >> 1;
            if (check(mid)) r = mid - 1, tag = mid;
                else l = mid + 1;
        }
        printf("%lld\n", tag);
    }


    return 0;
}
```

### [D - Hero of the Kingdom](https://codeforces.com/gym/526653/problem/D)

搬运 $x$ 袋面粉需要的时间 $t = (a + c)x + (b + d)$ ，需要花费的金币 $s = px$ ，赚到的利润是 $(q - p)x$ 

一个模拟的思路就是根据金币数和剩余时间计算出最多能搬运多少袋面粉，一直重复直到一袋面粉都运不了

但是会超时，仔细想一下会发现当卖一袋面粉收入太少，就会导致多次卖相同数量的面粉，所以如果两次卖的面粉数量相同，我们可以计算出最少还要卖多少次才能使下次卖的面粉数量增加，这样对每一数量的面粉我们最多会卖两次，因为卖一袋面粉的时间最少是 $2$ ，所以最坏情况下需要卖的次数 $k$ 满足 $\Sigma_{i = 1}^k 2\times2i \geq t$ ，差不多是 $O(\sqrt{t})$ 的复杂度

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int T;
LL p, a, b, q, c, d;
LL m, t;
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}
LL calc(LL x) {
    return a * x + b + c * x + d;
}
int main()
{
    T = read();
    while (T--) {
        p = read(); a = read(); b = read();
        q = read(); c = read(); d = read();
        m = read(); t = read();

        LL M = a + b + c + d;
        LL pro = 0, lst = 0;
        while (t >= M && m >= p) {
            LL mx = m / p;
            if (calc(mx) > t) {
                mx = (t - b - d) / (a + c);
                m += (pro = mx * (q - p));
                t -= calc(mx);
            } else {
                if (mx != lst) {
                    lst = mx;
                    m += (pro = mx * (q - p));
                    t -= calc(mx);
                } else {
                    LL ned = (lst + 1) * p - m;
                    LL nedtime = (ned + pro - 1) / pro;
                    LL time = min(nedtime, t / calc(mx));
                    m += time * pro;
                    t -= time * calc(mx);
                }
            }
        }

        printf("%lld\n", m);
    }


    return 0;
}
```

### [E - Sensors](https://codeforces.com/gym/526653/problem/E)

一个观测区间只会在蓝色球变成一球和零球时对答案产生贡献，这种问题很重要的地方就是如何判断每次操作使哪些区间产生了上述变化，这里可以考虑线段树

我们把每个观测区间挂到线段树对应的节点上，这样最多会被分成 $logn$ 段，当一个线段树区间上蓝色球的数量变成 $1$ 时，说明挂在上面的区间有可能进入一个蓝色球的状态，就去更新这些区间的状态，看会不会对答案产生贡献。当一个线段树区间变成 $0$ 时，说明上面的区间有可能进入零球状态，也可能是一球，也挨个更新状态。

这样每个区间最多只会被更新 $2logn$ 次，时间复杂度 $O(nlogn)$

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn = 5e5 + 5;
int T;
int n, m;
int sum[maxn];
LL ans;

int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

int t[maxn << 2];
struct node {
    int l, r, id;
};
vector<node> s[maxn << 2]; 

void build(int l, int r, int p) {
    while (!s[p].empty()) s[p].clear();
    if (l == r) return t[p] = 1, void();
    int mid = (l + r) >> 1;
    build(l, mid, p << 1);
    build(mid + 1, r, p << 1 | 1);
    t[p] = t[p << 1] + t[p << 1 | 1];
}
void push(int l, int r, int x, int y, int k, int p) {
    if (x <= l && r <= y) {
        s[p].push_back({x, y, k});
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) push(l, mid, x, y, k, p << 1);
    if (y > mid) push(mid + 1, r, x, y, k, p << 1 | 1);
}
void check(int L, int R, int p) {
    for (auto [l, r, k] : s[p]) {
        if (t[p] == 1) sum[k] += L - R;
            else sum[k]--;

        if (sum[k] == 0) ans -= 1ll * k * k;
        if (sum[k] == 1) ans += 1ll * k * k;
    }
}
void update(int l, int r, int x, int p) {
    if (l == r) {
        t[p] = 0;
        check(l, r, p);
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) update(l, mid, x, p << 1);
    if (x > mid) update(mid + 1, r, x, p << 1 | 1);
    t[p] = t[p << 1] + t[p << 1 | 1];

    if (t[p] <= 1) check(l, r, p);
}
int main()
{
    T = read();
    while (T--) {
        n = read(); m = read();
        build(1, n, 1);

        ans = 0;
        for (int i = 1; i <= m; i++) {
            int x, y;
            x = read(); y = read();
            x++, y++;
            push(1, n, x, y, i, 1);
            sum[i] = y - x + 1;
            if (x == y) ans += 1ll * i * i;
        }
        printf("%lld ", ans);

        for (int i = 1; i <= n; i++) {
            int x;
            x = read();
            x = (x + ans) % n + 1;
            update(1, n, x, 1);
            printf("%lld ", ans);
        }
        putchar('\n');
    }

    return 0;
}
```

### [F - Divide the Sequence](https://codeforces.com/gym/526653/problem/F)

当 $k = n$ 时，答案为 $\Sigma i \times a_i$

如果要合并某两个区间，对答案的贡献就是减去一次到第二个区间的后缀和，且到每个区间的后缀和仅会被计算一次

那么贪心地考虑就是每次找出最小后缀和合并，排个序就行了

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn = 5e5 + 5;
int T;
int n;
LL a[maxn], s[maxn];
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}
int main()
{
    T = read();
    while (T--) {
        n = read();
        for (int i = 1; i <= n; i++) a[i] = read();

        s[n + 1] = 0;
        for (int i = n; i; i--) s[i] = s[i + 1] + a[i];
        sort(s + 2, s + 1 + n);

        for (int i = n; i >= 2; i--) s[i] += s[i + 1];
        for (int i = 1; i <= n; i++)
            printf("%lld ", s[1] + s[n - i + 2]);
        putchar('\n');
    }

    return 0;
}
```

### [H - Stop the Castle](https://codeforces.com/gym/526653/problem/H)

就给下思路吧，我实在不想调这个题（

对能互相攻击到的车连线并编号，对于相交的两条连线，在对应的两条边编号建边，最后跑二分图匹配即可

匹配到的边就是取对应的连线交点，没有匹配的在连线上任取一点即可

思路很简单吧，接下来来码一下叭:P

### [I - Left Shifting](https://codeforces.com/gym/526653/problem/I)

签到

模拟扫一遍

### [J - Colorful Spanning Tree](https://codeforces.com/gym/526653/problem/J)

要让每个点都相连，对于每种颜色的点至少有一个会和其他颜色的点相连，这些点就可以构成一棵最小生成树，剩下的点取最小权值往上连就好了

### [K - Matrix](https://codeforces.com/gym/526653/problem/K)

简单小构造

首先互不相同的那个四个位置，对应的同列或者同行的两个位置一定是相同的，就可以取四个数塞到角落，剩下同行同列的位置从 $1$ 到 $2n - 4$ 每个塞两个。

这个时候还剩下一个 $(n - 2) \times (n - 2)$ 的矩阵，把前 $n - 2$ 行的延伸过来就行了。

这样当 $1 \leq a \leq n - 2$ 时，因为这一行都相等，四元组一定不符合条件

当 $a = n - 1$ 时，如果 $c \leq n - 2$ ，这列最后两个值相同，也不符合条件

唯一满足的四个数是角落的四个，符合题意。

实际如下：

$$
\begin{bmatrix}
1 & 1 & 1 & \cdots & 1 & 1 & 1 \\
2 & 2 & 2 & \cdots & 2 & 2 & 2 \\
3 & 3 & 3 & \cdots & 3 & 3 & 3 \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots & \vdots \\
n - 2 & n - 2 & n - 2 & \cdots & n - 2 & n - 2 & n - 2 \\
n - 1 & n & n + 1 & \cdots & 2n - 4 & 2n - 3 & 2n - 2\\ 
n - 1 & n & n + 1 & \cdots & 2n - 4 & 2n - 1 & 2n\\
\end{bmatrix}
$$

我也不知道我为什么要用矩阵写，可能为了练练 `Latex` 把（

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn = 5e1 + 5;
int n;
int ans[maxn][maxn];
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}
int main()
{
    n = read();
    for (int i = 1; i <= n - 2; i++)
        for (int j = 1; j <= n; j++)
            ans[i][j] = i;
    for (int j = 1; j <= n - 2; j++)
        ans[n - 1][j] = ans[n][j] = n + j - 2;
    ans[n - 1][n - 1] = 2 * n - 3;
    ans[n - 1][n] = 2 * n - 2;
    ans[n][n - 1] = 2 * n - 1;
    ans[n][n] = 2 * n;

    printf("Yes\n");
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++)
            printf("%d ", ans[i][j]);
        putchar('\n');
    }

    return 0;
}
```

### [M - Palindromic Polygon](https://codeforces.com/gym/526653/problem/M)

区间dp

先把环展开为长度 $2n$ 的链，然后令 $f_{i, j}$ 表示从第 $i$ 个点取到第 $j$ 个点围成的最大面积（需要满足 $i,j$ 为 回文串的一部分）

然后就是按长度枚举区间，对于每个区间 $[i, j]$ ，枚举 $i$ 左边的所有点，并找到 $j$ 后面第一个对应的相同权值相同的点，从 $[i, j]$ 向新的区间转移，然后再枚举一下 $j$ 右边的点，时间复杂度 $O(n^3)$ 

$ans$ 取计算过程中的最大值

珍爱生命，远离海伦公式

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn = 1e3 + 5;
const int inf = 1e9;
int T;
int n;
int a[maxn], f[maxn];
struct point {
    int x, y;
}p[maxn];
struct vec {
    LL x, y;
};
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}
LL getS(int p1, int p2, int p3) {
    vec d1 = {p[p1].x - p[p2].x, p[p1].y - p[p2].y};
    vec d2 = {p[p1].x - p[p3].x, p[p1].y - p[p3].y};
    return abs(d1.x * d2.y - d2.x * d1.y);
}
int main()
{
    T = read();
    while (T--) {
        n = read();
        for (int i = 1; i <= n; i++) f[i] = a[i] = read();
        for (int i = 1; i <= n; i++)
            p[i] = {read(), read()};

        sort(a + 1, a + 1 + n);
        int len = unique(a + 1, a + 1 + n) - a - 1;
        for (int i = 1; i <= n; i++) 
            f[i] = lower_bound(a + 1, a + 1 + len, f[i]) - a;

        for (int i = n + 1; i <= 2 * n; i++) f[i] = f[i - n], p[i] = p[i - n];

        vector<int> v(n + 5);
        vector<vector<int> > nxt(2 * n + 5, vector (2 * n + 5, inf)), lst(2 * n + 5, vector (2 * n + 5, -inf));
        vector<vector<LL> > dp(2 * n + 5, vector(2 * n + 5, 0ll));
        v.assign(n + 5, inf);
        for (int i = 2 * n; i; i--) {
            for (int j = 1; j <= n; j++)
                nxt[i][j] = v[j];
            v[f[i]] = i;
        }
        v.assign(n + 5, -inf);
        for (int i = 1; i <= 2 * n; i++) {
            for (int j = 1; j <= n; j++)
                lst[i][j] = v[j];
            v[f[i]] = i;
        }

        v.assign(n + 5, 0);
        int id = 0;
        LL ans = 0;
        for (int len = 1; len <= n; len++) {
            for (int i = 1; i <= 2 * n - len + 1; i++) {
                int j = i + len - 1;
                if (f[i] != f[j]) continue;

                id++;
                for (int pre = i - 1; pre; pre--) {
                    if (j - pre + 1 > n) break;
                    if (v[f[pre]] == id) continue;
                    v[f[pre]] = id;
                    LL succ = nxt[j][f[pre]];
                    while (succ - pre + 1 <= n) {
                        LL exS = getS(i, j, pre) + getS(pre, succ, j);
                        dp[pre][succ] = max(dp[pre][succ], dp[i][j] + exS);
                        succ = nxt[succ][f[pre]];
                    }
                }
                id++;
                for (int succ = j + 1; succ <= 2 * n; succ++) {
                    if (succ - i + 1 > n) break;
                    if (v[f[succ]] == id) continue;
                    v[f[succ]] = id;
                    LL pre = lst[i][f[succ]];
                    while (succ - pre + 1 <= n) {
                        LL exS = getS(i, j, pre) + getS(pre, succ, j);
                        dp[pre][succ] = max(dp[pre][succ], dp[i][j] + exS);
                        pre = lst[pre][f[succ]];
                    }
                }
                ans = max(ans, dp[i][j]);
            }
        }
        printf("%lld\n", ans);
    }

    return 0;
}
```
