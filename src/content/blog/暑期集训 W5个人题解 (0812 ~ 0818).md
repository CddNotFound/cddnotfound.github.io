---
title: '暑期集训 W5个人题解 (0812 - 0818)'
description: ''
publishDate: 2024-08-19
tags:
  - ACM
  - 多校
  - 总结
---
<!-- more --> 

为什么没有杭电，因为摸了（

## 牛客多校09 :

### [A - Image Scaling](https://ac.nowcoder.com/acm/contest/81604/A)

算一下矩形的长和宽

长宽同除 gcd 后输出即可

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 5e2 + 5;
int n, m;
int a[maxn][maxn];
char ch[maxn];
int col[maxn][maxn], row[maxn][maxn];
int x, y;

int gcd(int a, int b) {
    return !b ? a : gcd(b, a % b);
}
int main()
{
    n = read(); m = read();
    for (int i = 1; i <= n; i++) {
        scanf("%s", ch + 1);
        for (int j = 1; j <= m; j++)
            a[i][j] = ch[j] == 'x';
    }

    x = y = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            col[i][j] = a[i][j] + col[i - 1][j], row[i][j] = a[i][j] + row[i][j - 1];
            x = max(x, col[i][j]);
            y = max(y, row[i][j]);
        }

    int tmp = gcd(x, y);
    x /= tmp, y /= tmp;

    for (int i = 1; i <= x; i++) {
        for (int j = 1; j <= y; j++)
            putchar('x');
        putchar('\n');
    }

    return 0;
}
```

### [B - Break Sequence](https://ac.nowcoder.com/acm/contest/81604/B)

令 $dp_i$ 表示以 $i$ 为结尾的合法分配方案数

转移就是前面所有合法 $i$ 的 $dp_i$ 的和

根据题意，不合法的位置一定是一段一段的区间，不超过 $m$ 个，考虑用线段树维护。每到下一个位置，更新这个数对应的不合法区间（将原来的区间-1，新的区间+1）。线段树维护区间最小值和区间内最小值对应的 $dp_i$ 的和， pushup的时候比较最小值并更新对应的和。

如果 $[0，i - 1]$ 对应的最小值为 0，$dp_i$ 就是这个和，否则说明合法方案数为 0 
#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

const int P = 998244353;
template<const int mod>
struct ModInt {
    static const int P = mod;
    int x;
    ModInt (int x = 0) : x(x % P) {}
    ModInt (LL x) : x(int(x % P)) {}
    int val() {return x;}

    ModInt operator + (const ModInt &a) const {int x0 = x + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    ModInt operator - (const ModInt &a) const {int x0 = x - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    ModInt operator * (const ModInt &a) const {return ModInt(1ll * x * a.x % P);}
    ModInt operator / (const ModInt &a) const {return *this * a.inv();}
    bool operator == (const ModInt &a) const {return x == a.x;};
    bool operator != (const ModInt &a) const {return x != a.x;};
    void operator += (const ModInt &a) {x += a.x; if (x >= P) x -= P;}
    void operator -= (const ModInt &a) {x -= a.x; if (x < 0) x += P;}
    void operator *= (const ModInt &a) {x = 1ll * x * a.x % P;}
    void operator /= (const ModInt &a) {*this = *this / a;}
    friend ModInt operator + (int y, const ModInt &a){int x0 = y + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    friend ModInt operator - (int y, const ModInt &a){int x0 = y - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    friend ModInt operator * (int y, const ModInt &a){return ModInt(1ll * a.x * y % P);}
    friend ModInt operator / (int y, const ModInt &a){return ModInt(y) / a;}
    friend ostream &operator<<(ostream &os, const ModInt &a) {return os << (a.x + P) % P;}
    friend istream &operator>>(istream &is, ModInt &t) {return is >> t.x;}

    ModInt pow(LL n) const {
       ModInt sum(1), base(x);
       n %= (P - 1);
       while (n) {
           if (n & 1) sum *= base;
           base *= base;
           n >>= 1;
       }
       return sum;
    }

    ModInt inv() const {
        int a = x, b = P, x = 1, y = 0;
        while (b) {
        int t = a / b;
           a -= t * b; swap(a, b);
           x -= t * y; swap(x, y);
        }
        if (x < 0) y += P;
        return x;
    }
};
using mint = ModInt<P>;

const int maxn = 2e5 + 5;
const int maxm = 1e1 + 5;
const int inf = 1e9;

int n, m;
int a[maxn], b[maxm];

struct node {
    int mn;
    mint s;
};

node t[maxn << 2];
int lazy[maxn << 2];

void pushup(int l, int r, int p) {
    if (l == r) return ;
    t[p].mn = min(t[p << 1].mn, t[p << 1 | 1].mn);
    if (t[p << 1].mn == t[p << 1 | 1].mn) t[p].s = t[p << 1].s + t[p << 1 | 1].s;
        else t[p].s = t[p << 1].mn < t[p << 1 | 1].mn ? t[p << 1].s : t[p << 1 | 1].s;
}
void pushdown(int l, int r, int p) {
    if (l == r) return lazy[p] = 0, void();
    if (lazy[p]) {
        int k = lazy[p], ls = p << 1, rs = p << 1 | 1;
        lazy[ls] += k, lazy[rs] += k;
        t[ls].mn += k, t[rs].mn += k;
        lazy[p] = 0;
    }
}
void build(int l, int r, int p) {
    if (l == r) return t[p] = {0, 0}, void();
    int mid = (l + r) >> 1;
    build(l, mid, p << 1);
    build(mid + 1, r, p << 1 | 1);
    pushup(l, r, p);
}
void update(int l, int r, int x, int y, int k, int p) {
    if (x <= l && r <= y) {
        lazy[p] += k;
        t[p].mn += k;
        return ;
    }
    pushdown(l, r, p);
    int mid = (l + r) >> 1;
    if (x <= mid) update(l, mid, x, y, k, p << 1);
    if (y > mid) update(mid + 1, r, x, y, k, p << 1 | 1);
    pushup(l, r, p);
}
void updateval(int l, int r, int x, mint k, int p) {
    if (l == r) {
        t[p].s = k;
        return ;
    }
    pushdown(l, r, p);
    int mid = (l + r) >> 1;
    if (x <= mid) updateval(l, mid, x, k, p << 1);
        else updateval(mid + 1, r, x, k, p << 1 | 1);
    pushup(l, r, p);
}
node query(int l, int r, int x, int y, int p) {
    if (x <= l && r <= y) {
        return t[p];
    }
    int mid = (l + r) >> 1;
    node sum = {inf, 0};
    if (x <= mid) {
        auto tmp = query(l, mid, x, y, p << 1);
        if (tmp.mn < sum.mn) sum = tmp;
            else if (tmp.mn == sum.mn) sum.s += tmp.s;
    }
    if (y > mid) {
        auto tmp = query(mid + 1, r, x, y, p << 1 | 1);
        if (tmp.mn < sum.mn) sum = tmp;
            else if (tmp.mn == sum.mn) sum.s += tmp.s;
    }
    return sum;
}

int main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    cin >> n >> m;
    for (int i = 2; i <= n + 1; i++) cin >> a[i];
    for (int i = 1; i <= m; i++) cin >> b[i];
    sort(b + 1, b + 1 + m);

    vector<int> nxt(n + 5, n + 1), pos(n + 5, 1), pre(n + 5, 1);
    for (int i = 2; i <= n + 1; i++) {
        pre[i] = pos[a[i]];
        pos[a[i]] = i;
    }
    pos.assign(n + 5, n + 2);
    for (int i = n + 1; i >= 2; i--) {
        nxt[i] = pos[a[i]];
        pos[a[i]] = i;
    }

    vector<int> cnt(n + 5, 0), p(n + 5, 1);
    vector<vector<int>> seg(n + 5, vector<int>());
    vector<mint> dp(n + 5, 0);

    build(1, n + 1, 1);
    updateval(1, n + 1, 1, 1, 1);
    dp[1] = 1;
    for (int i = 2; i <= n + 1; i++) {
        for (auto &v : seg[a[i]]) {
            if (v <= n + 1) update(1, n + 1, pre[v], v - 1, -1, 1);
            v = nxt[v];
            if (v <= n + 1) update(1, n + 1, pre[v], v - 1, 1, 1);
        }

        cnt[a[i]]++;
        if (p[a[i]] <= m) {
            if (cnt[a[i]] >= b[p[a[i]]]) {
                seg[a[i]].push_back(pos[a[i]]);
                update(1, n + 1, 1, pos[a[i]] - 1, 1, 1);
                p[a[i]]++;
            }
        }

        auto tmp = query(1, n + 1, 1, i - 1, 1);
        if (tmp.mn == 0) dp[i] = tmp.s;
        updateval(1, n + 1, i, dp[i], 1);
    }

    cout << dp[n + 1] << "\n";

    return 0;
}
```

### [C - Change Matrix](https://ac.nowcoder.com/acm/contest/81604/C)

首先如果矩阵中每个格子的值都相等，最终整个矩阵的值就是每一行的倍数和与每一列的倍数和的乘积

因为 $gcd(i, j) = \sum_{x|i, x|j}\phi(x)$ ，就可以用 $n$ 个大小为 $\lfloor \frac {n} {i} \rfloor$ ，每格初始值均为 $\phi(i)$ 的矩阵来“凑”出原矩阵

每次更新时，更新第 $i$ 个矩阵的 $\lfloor \frac {x} {i} \rfloor$ 行/列，并更新这个矩阵行和列的倍数和即可，其中 $i$ 满足 $i\ |\ x$

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

const int P = 1e9 + 7;
template<const int mod>
struct ModInt {
    static const int P = mod;
    int x;
    ModInt (int x = 0) : x(x % P) {}
    ModInt (LL x) : x(int(x % P)) {}
    int val() {return x;}

    ModInt operator + (const ModInt &a) const {int x0 = x + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    ModInt operator - (const ModInt &a) const {int x0 = x - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    ModInt operator * (const ModInt &a) const {return ModInt(1ll * x * a.x % P);}
    ModInt operator / (const ModInt &a) const {return *this * a.inv();}
    bool operator == (const ModInt &a) const {return x == a.x;};
    bool operator != (const ModInt &a) const {return x != a.x;};
    void operator += (const ModInt &a) {x += a.x; if (x >= P) x -= P;}
    void operator -= (const ModInt &a) {x -= a.x; if (x < 0) x += P;}
    void operator *= (const ModInt &a) {x = 1ll * x * a.x % P;}
    void operator /= (const ModInt &a) {*this = *this / a;}
    friend ModInt operator + (int y, const ModInt &a){int x0 = y + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    friend ModInt operator - (int y, const ModInt &a){int x0 = y - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    friend ModInt operator * (int y, const ModInt &a){return ModInt(1ll * a.x * y % P);}
    friend ModInt operator / (int y, const ModInt &a){return ModInt(y) / a;}
    friend ostream &operator<<(ostream &os, const ModInt &a) {return os << (a.x + P) % P;}
    friend istream &operator>>(istream &is, ModInt &t) {return is >> t.x;}

    ModInt pow(LL n) const {
       ModInt sum(1), base(x);
       n %= (P - 1);
       while (n) {
           if (n & 1) sum *= base;
           base *= base;
           n >>= 1;
       }
       return sum;
    }

    ModInt inv() const {
        int a = x, b = P, x = 1, y = 0;
        while (b) {
        int t = a / b;
           a -= t * b; swap(a, b);
           x -= t * y; swap(x, y);
        }
        if (x < 0) y += P;
        return x;
    }
};
using mint = ModInt<P>;

const int maxn = 1e5 + 5;

int n, Q;
int phi[maxn];
char ch[5];

void init(int x) {
    phi[1] = 1;
    for (int i = 2; i <= x; i++) {
        phi[i] = i - 1;
        for (int j = 2; j * j <= i; j++) {
            if (i % j == 0) {
                phi[i] -= phi[j];
                if (j * j != i) phi[i] -= phi[i / j];
            }
        }
    }
}

int main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    init(1e5);

    cin >> n >> Q;

    vector<vector<vector<mint>>> matrix(n + 5);
    vector<vector<mint>> sum(n + 5);
    mint ans = 0;
    for (int i = 1; i <= n; i++) {
        matrix[i].assign(n / i + 5, {1, 1});
        sum[i].assign({n / i, n / i});
        ans += phi[i] * sum[i][0] * sum[i][1];
    }

    while (Q--) {
        int opt, x, y;
        cin >> ch >> x >> y;
        opt = ch[0] == 'R' ? 0 : 1;

        vector<int> p;
        for (int i = 1; i * i <= x; i++) {
            if (x % i == 0) {
                p.push_back(i);
                if (i * i != x) p.push_back(x / i);
            }
        }

        for (auto v : p) {
            ans -= sum[v][0] * sum[v][1] * phi[v];
            sum[v][opt] -= matrix[v][x / v][opt];
            matrix[v][x / v][opt] *= y;
            sum[v][opt] += matrix[v][x / v][opt];
            ans += sum[v][0] * sum[v][1] * phi[v];
        }
        cout << ans << "\n";
    }
    
    return 0;
}
```

### [H - Two Convex Polygons](https://ac.nowcoder.com/acm/contest/81604/H)

计算方法不难想，就是 A 的周长加上以 B 的直径为半径的圆的周长

题目凸多边形的点按顺序给出，旋转卡壳求下直径就行了

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
#define int long long 
using namespace std;

int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 1e6 + 5;
const double pi = 3.141592653589793238;

int T;
int n, m;
struct node {
    int x, y; 
}a[maxn], b[maxn];

LL dis(int x, int y) {
    int delx = b[x].x - b[y].x, dely = b[x].y - b[y].y;
    return delx * delx + dely * dely;
}
double len(node d) {
    return sqrt(1.0 * d.x * d.x + 1.0 * d.y * d.y);
}

signed main()
{
    T = read();
    while (T--) {
        n = read();
        for (int i = 1; i <= n; i++) a[i] = {read(), read()};
        m = read();
        for (int i = 1; i <= m; i++) b[i] = {read(), read()};

        double mx = 0;
        
        int now = 1;

        b[m + 1] = b[1];
        for (int i = 1; i <= m; i++) {
            node x = b[i], y = b[i + 1];
            node v1 = {x.x - y.x, x.y - y.y}, v2 = {0, 0};
            LL dis1 = 0, dis2 = 0;
            int nxt = now == m ? 1 : now + 1;
            v2 = {x.x - b[now].x, x.y - b[now].y};
            dis1 = abs(v1.x * v2.y - v1.y * v2.x);
            v2 = {x.x - b[nxt].x, x.y - b[nxt].y};
            dis2 = abs(v1.x * v2.y - v1.y * v2.x);
            while (dis1 <= dis2) {
                now = nxt;
                nxt = now == m ? 1 : now + 1;
                v2 = {x.x - b[now].x, x.y - b[now].y};
                dis1 = abs(v1.x * v2.y - v1.y * v2.x);
                v2 = {x.x - b[nxt].x, x.y - b[nxt].y};
                dis2 = abs(v1.x * v2.y - v1.y * v2.x);
            }

            mx = max(mx, 1.0 * max(dis(i, now), dis(i + 1, now)));
        }
        double ans = 0;
        mx = sqrt(mx);
        ans = mx * 2 * M_PI;

        a[0] = a[n];
        for (int i = 1; i <= n; i++) {
            node v1 = {a[i].x - a[i - 1].x, a[i].y - a[i - 1].y};
            ans += len(v1);
        }
        printf("%.15lf\n", ans);
    }
    
    return 0;
}
```

### [I - Interesting Numbers](https://ac.nowcoder.com/acm/contest/81604/I)

分别用 $ll, lr, rl, rr$ 表示 L 和 R 的左半边和右半边， $ansl, ansr$ 表示构造出的左右半边

当 $ll < ansl < rl$ 时， $ansr$ 可以是长度不超过 $\frac {n} {2}$ 的任意平方数

当 $ll = ansl$ 时， $ansr$ 是大于等于 $lr$ 的任意平方数

当 $rl = ansl$ 时， $ansr$ 是小于等于 $rr$ 的任意平方数

接下来搓个高精度就好了（没有高精模板是这样的

注意不要漏算多算了 $ansr = 0$ 的情况
#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
#define int long long
using namespace std;

int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 1e2 + 5;

int n, mm;
LL low = 0;
char L[maxn], R[maxn];
int ll[maxn], lr[maxn], rl[maxn], rr[maxn];
int ddd[maxn];

LL gets(int *std, int t) {
    std[1] += t;
    for (int i = 1; i <= mm; i++)
        if (std[i] < 0) std[i] += 10, std[i + 1]--;
            else break;
    if (std[mm + 1] < 0) return 0;

    LL l = low, r = low * 1000 - 1, tag = 0;
    while (l <= r) {
        int mid = (l + r) >> 1;
        int tmp = mid;
        vector<int> a(mm + 5, 0), b(mm + 5, 0), c(mm + 10, 0);

        int tot = 0;
        while (tmp) {
            ++tot;
            a[tot] = b[tot] = tmp % 10;
            tmp /= 10;
        }
        for (int i = 1; i <= tot; i++)
            for (int j = 1; j <= tot; j++)
                c[i + j - 1] += a[i] * b[j];
        for (int i = 1; i <= mm + 7; i++)
            if (c[i] >= 10) c[i + 1] += c[i] / 10, c[i] %= 10;

        int ff = 1;
        for (int i = mm + 8; i; i--)
            if (c[i] > std[i]) {ff = 0; break;}
                else if (c[i] < std[i]) {ff = 1; break;}
        if (ff) l = mid + 1, tag = mid;
            else r = mid - 1;
    }
    std[1] -= t;
    for (int i = 1; i <= mm; i++)
        std[i + 1] += std[i] / 10, std[i] %= 10;

    return tag + 1;
}

int check(int *std) {
    LL l = low, r = low * 100 - 1, ff = 0;
    while (l <= r) {
        int mid = (l + r) >> 1;

        int tmp = mid;
        vector<int> a(mm + 5, 0), b(mm + 5, 0), c(mm + 10, 0);

        int tot = 0;
        while (tmp) {
            ++tot;
            a[tot] = b[tot] = tmp % 10;
            tmp /= 10;
        }
        for (int i = 1; i <= tot; i++)
            for (int j = 1; j <= tot; j++)
                c[i + j - 1] += a[i] * b[j];
        for (int i = 1; i <= mm + 7; i++)
            if (c[i] >= 10) c[i + 1] += c[i] / 10, c[i] %= 10;

        int ff = 1;
        for (int i = mm + 8; i; i--)
            if (std[i] != c[i]) {ff = 0; break;}

        if (ff) return 1;
        ff = 1;
        for (int i = mm + 8; i; i--)
            if (c[i] > std[i]) {ff = 0; break;}
                else if (c[i] < std[i]) {ff = 1; break;}
        if (ff) l = mid + 1;
            else r = mid - 1;
    }
    return 0;
}

signed main()
{
    n = read();
    mm = n / 2;
    scanf("%s %s", L, R);
    int cnt = 0;
    for (int i = n - 1; i >= mm; i--) ++cnt, lr[cnt] = L[i] ^ 48, rr[cnt] = R[i] ^ 48;
    cnt = 0;
    for (int i = mm - 1; i >= 0; i--) ++cnt, ll[cnt] = L[i] ^ 48, rl[cnt] = R[i] ^ 48;
    low = 1;
    for (int i = 2; i <= mm / 2; i++) low *= 10;

    LL tmp = gets(rl, -1) - gets(ll, 0);

    for (int i = 1; i <= mm; i++) ddd[i] = 9;

    vector<int> a(maxn, 0), b(maxn, 0), c(maxn, 0), ans(maxn, 0);
    a.assign(maxn, 0);
    int cnta = 0, cntb = 0, cntc = 0, cntans = 0;
    while (tmp) {
        a[++cnta] = tmp % 10;
        tmp /= 10;
    }

    b.assign(maxn, 0);
    tmp = gets(ddd, 0);
    while (tmp) {
        b[++cntb] = tmp % 10;
        tmp /= 10;
    }

    for (int i = 1; i <= cnta; i++) 
        for (int j = 1; j <= cntb; j++)
            c[i + j - 1] += a[i] * b[j];
    for (int i = 1; i <= cnta + cntb + 5; i++)
        c[i + 1] += c[i] / 10, c[i] %= 10;
    cntc = cnta + cntb + 6;
    while (!c[cntc]) cntc--;
    ans = c;
    ans[0] = cntc;

    if (check(ll)) {
        a.assign(maxn, 0);
        b.assign(maxn, 0);
        c.assign(maxn, 0);
        cnta = cntb = cntc = 0;

        tmp = gets(ddd, 0);
        while (tmp) {a[++cnta] = tmp % 10; tmp /= 10;}
        tmp = gets(lr, -1);
        while (tmp) {b[++cntb] = tmp % 10; tmp /= 10;}

        for (int i = 1; i <= max(cnta, cntb); i++) {
            c[i] += a[i] - b[i];
            if (c[i] < 0) c[i] += 10, c[i + 1]--;
        }
        cntc = max(cnta, cntb) + 4;
        while (!c[cntc]) cntc--;
        ans[0] = max(ans[0], cntc);
        for (int i = 1; i <= ans[0]; i++) {
            ans[i] += c[i];
            ans[i + 1] += ans[i] / 10;
            ans[i] %= 10;
        }
        ans[0] += 5;
        while (!ans[ans[0]]) ans[0]--;
    }

    if (check(rl)) {
        a.assign(maxn, 0);
        cnta = 0;

        tmp = gets(rr, 0);
        while (tmp) {a[++cnta] = tmp % 10; tmp /= 10;}

        ans[0] = max(ans[0], cnta);
        for (int i = 1; i <= ans[0]; i++) {
            ans[i] += a[i];
            ans[i + 1] += ans[i] / 10;
            ans[i] %= 10;
        }
        ans[0] += 5;
        while (!ans[ans[0]]) ans[0]--;
    }

    for (int i = ans[0]; i; i--)
        putchar(ans[i] ^ 48);
    putchar('\n');

    return 0;
}       
```

### [K - Kill The Monsters](https://ac.nowcoder.com/acm/contest/81604/K)

签到2

肯定是对当前血量最大且大于 $2$ 的敌人进行 2 操作

开个堆统计最大血量，每次操作后计算步数更新答案即可

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 2e5 + 5;

int n, k;

int main()
{
    n = read(); k = read();
    priority_queue<int> q;
    for (int i = 1; i <= n; i++) {
        int x;
        x = read();
        q.push(x);
    }
    if (k == 1) return printf("%d\n", q.top()), 0;

    LL ans = q.top(), cnt = 0;
    while (q.top() > 1) {
        int now = q.top();
        q.pop();
        q.push(now / k);
        cnt++;

        ans = min(ans, q.top() + cnt);
    }

    printf("%lld\n", ans);

    return 0;
}
```

## 牛客多校10 :

### [A - Surrender to My Will](https://ac.nowcoder.com/acm/contest/81605/A)

签到1

票数大于等于四是投降，否则反对票不超过一张为不确定

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

char ch[10];
int main()
{
    scanf("%s", ch + 1);

    int cnt = 0;
    int eq = 0;
    for (int i = 1; i <= 5; i++) {
        cnt += ch[i] == 'Y';
        eq += ch[i] == '-';
    }

    if (cnt >= 4) printf("1\n");
        else if (eq + cnt >= 4) printf("0\n");
        else printf("-1\n");


    return 0;
}
```

### [B - std::pair](https://ac.nowcoder.com/acm/contest/81605/B)

我觉得是能算签到的但是懒得写，讨厌字符串模拟.jpg（

对每个变量建棵二叉树遍历输出就行

### [D - Is it rated?](https://ac.nowcoder.com/acm/contest/81605/D)

当 $k = 0.9$ 时前面的比赛对最终 rating 影响最大，$0.9^{200} \approx 0.000000000000018739 < 10e-13$ ，说明后 300 场之前的比赛在误差范围内可以看作对答案无影响

令 $dp_i$ 表示比了 $i$ 场的最大 rating ，边界条件 $dp_0 = r_0$ ，只要计算 $[1, 300]$ 范围内的即可

当 $n \geq m + 300$ ，说明至少有 300 场 rated，答案就是 $dp_{300}$

当 $n < m + 300$ ，说明可以 rated 场数的范围是 $[n - m, min(len, n)]$ ，在这个范围内取最大值即可

--- 

因为觉得 233 不是很稳就用 332 了（bushi

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 1e5 + 5;
const int len = 332;

int T;
int n, m, r;
double k;
int a[maxn];

int main()
{
    scanf("%d", &T);
    while (T--) {
        scanf("%d%d%lf", &n, &m, &k);
        scanf("%d", &r);
        for (int i = 1; i <= n; i++) scanf("%d", &a[i]);

        vector<double> dp(len + 5, -1);
        dp[0] = r;
        for (int i = max(1, n - m - len + 1); i <= n; i++) {
            for (int j = len - 1; j >= 0; j--)
                if (dp[j] != -1) dp[j + 1] = max(dp[j + 1], dp[j] * (1 - k) + k * a[i]);
        }
        
        double ans = dp[len];
        for (int i = min(len, n); i >= n - m; i--)
        for (int i = n - m; i <= min(len, n); i++)
            ans = max(ans, dp[i]);
            
        printf("%.12lf\n", ans);
    }

    return 0;
}
```

### [F - Collinear Exception](https://ac.nowcoder.com/acm/contest/81605/F)

每行最多插入两个点，最终成功插入的点不会超过 $2n$ 个

每当我们成功插入一个点时，暴力将每条边经过的点全部标记

我们用二元组 $(\Delta x, \Delta y)$ ($gcd(\Delta x, \Delta y) = 1$)来表示一条线，这条线经过的点数不会超过 $\lceil \frac {n} {max(\Delta x, \Delta y)} \rceil$，因为这个点与当前所有点构成的直线斜率互不相同，最差情况下一次操作会经过的点数数量级约为 $nlogn$ ，最终时间复杂度 $O(n^2logn)$

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 1e3 + 5;
const int maxm = 1e6 + 5;

int n;
int col[maxn], row[maxn];
int ans[maxm], v[maxn][maxn];

set<pair<int, int>> st;

int gcd(int a, int b) {
    return !b ? a : gcd(b, a % b);
}

void ins(int x, int y) {
    for (auto [xx, yy] : st) {
        if (x == xx || y == yy) continue;
        int dx = xx - x, dy = yy - y;
        if (dx < 0) dx = -dx, dy = -dy;
        int g = gcd(dx, dy);
        dx /= g, dy /= g;
        int tx = x, ty = y;
        while (tx >= 1 && ty >= 1 && tx <= n && ty <= n) v[tx][ty] = 1, tx -= dx, ty -= dy;
        tx = x, ty = y;
        while (tx <= n && ty <= n && tx >= 1 && ty >= 1) v[tx][ty] = 1, tx += dx, ty += dy;
    }
    st.insert({x, y});
}

int main()
{
    n = read();
    for (int i = 1; i <= n * n; i++) {
        int x, y;
        x = read(); y = read();
        if (col[y] >= 2 || row[x] >= 2) continue;
        if (v[x][y]) continue;
        ans[i] = 1;
        row[x]++, col[y]++;
        ins(x, y);
    }

    for (int i = 1; i <= n * n; i++)
        putchar(ans[i] ^ 48);
    putchar('\n');

    return 0;
}
```

### [H - All-in at the Pre-flop](https://ac.nowcoder.com/acm/contest/81605/H)

签到2

答案分别为 $\frac {a} {a + b}, \frac {b} {a + b}$

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

const int P = 998244353;
template<const int mod>
struct ModInt {
    static const int P = mod;
    int x;
    ModInt (int x = 0) : x(x % P) {}
    ModInt (LL x) : x(int(x % P)) {}
    int val() {return x;}

    ModInt operator + (const ModInt &a) const {int x0 = x + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    ModInt operator - (const ModInt &a) const {int x0 = x - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    ModInt operator * (const ModInt &a) const {return ModInt(1ll * x * a.x % P);}
    ModInt operator / (const ModInt &a) const {return *this * a.inv();}
    ModInt & operator ++ () {++x; return *this;}
    ModInt & operator -- () {--x; return *this;}
    bool operator == (const ModInt &a) const {return x == a.x;};
    bool operator != (const ModInt &a) const {return x != a.x;};
    void operator += (const ModInt &a) {x += a.x; if (x >= P) x -= P;}
    void operator -= (const ModInt &a) {x -= a.x; if (x < 0) x += P;}
    void operator *= (const ModInt &a) {x = 1ll * x * a.x % P;}
    void operator /= (const ModInt &a) {*this = *this / a;}
    friend ModInt operator + (int y, const ModInt &a){int x0 = y + a.x; return ModInt(x0 < P ? x0 : x0 - P);}
    friend ModInt operator - (int y, const ModInt &a){int x0 = y - a.x; return ModInt(x0 < 0 ? x0 + P : x0);}
    friend ModInt operator * (int y, const ModInt &a){return ModInt(1ll * a.x * y % P);}
    friend ModInt operator / (int y, const ModInt &a){return ModInt(y) / a;}
    friend ostream &operator<<(ostream &os, const ModInt &a) {return os << (a.x + P) % P;}
    friend istream &operator>>(istream &is, ModInt &t) {return is >> t.x;}

    ModInt pow(LL n) const {
       ModInt sum(1), base(x);
       n %= (P - 1);
       while (n) {
           if (n & 1) sum *= base;
           base *= base;
           n >>= 1;
       }
       return sum;
    }

    ModInt inv() const {
        int a = x, b = P, x = 1, y = 0;
        while (b) {
        int t = a / b;
           a -= t * b; swap(a, b);
           x -= t * y; swap(x, y);
        }
        if (x < 0) y += P;
        return x;
    }
};
using mint = ModInt<P>;

mint a, b;

int main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    cin >> a >> b;

    cout << a / (a + b) << ' ' << b / (a + b) << "\n";

    return 0;
}
```

### [K - Doremy's IQ 2](https://ac.nowcoder.com/acm/contest/81605/K)

不难发现移动方向最多变一次，要么先负后正，要么先正后负，要么一直朝一个方向走

我们枚举往负方向走到的位置，然后二分找到他能向正方向到的最远距离，计算最多有多少分然后更新答案，然后再把整个数组翻转再算一遍，时间复杂度 $O(nlogn)$

---

看了题解发现能双指针，nt了（

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 1e5 + 5;
int T;
int n, m;
int a[maxn];
int ans, ex;

void slove() {
    int tot0 = 0, tot1 = 0;
    vector<int> cnt0(m + 5, 0), cnt1(m + 5, 0);
    for (int i = 1; i <= n; i++) {
        if (a[i] < 0) tot0++;
            else if (a[i] > 0) tot1++;
        if (a[i] < 0) cnt0[-a[i]]++;
            else cnt1[a[i]]++;
    }
    for (int i = 1; i <= m; i++) cnt0[i] += cnt0[i - 1], cnt1[i] += cnt1[i - 1];
    for (int i = m; i >= 0; i--) {
        if (i && tot0 - cnt0[i - 1] < i) continue;
        int s = min(tot0 - i, cnt0[i]);
        int l = 1, r = m, tag = 0;
        while (l <= r) {
            int mid = (l + r) >> 1;
            int mx = tot1 - cnt1[mid - 1], dis = i + mid;
            if (mx >= dis) l = mid + 1, tag = max(tag, min(tot1 - dis, cnt1[mid]));
                else r = mid - 1;
        }
        ans = max(ans, tag + s);
    }
}
int main()
{
    T = read();
    while (T--) {
        m = read();

        ex = n = 0;
        for (int i = 1; i <= m; i++) {
            int x;
            x = read();
            if (x) a[++n] = x;
                else ex++;
        }
        ans = 0;

        slove();
        for (int i = 1; i <= n; i++) a[i] = -a[i];
        sort(a + 1, a + 1 + n);
        slove();

        printf("%d\n", ans + ex);
    }

    return 0;
}
```

### [L - Tada!](https://ac.nowcoder.com/acm/contest/81605/L)

密码最多 5 位，一共 1e5 种可能

令 $mov_{i, j}$ 表示初始状态全为0，移动 $i$ 步后，状态 $j$ 是否合法，并将不同步数的所有合法状态存入 vector，时间复杂度 $O(10^nnm)$

对每一条信息，我们将他能到达的所有合法状态次数+1，最终次数等于 m 的就是可能的密码

---

复杂度比题解高多了，但是时间比较宽松还是过了（

#### Code

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

int read() {
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') w = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + (ch ^ 48);
       ch = getchar();
    }
    return x * w;
}

const int maxn = 5e1 + 5;
const int maxm = 1e5 + 5;
const int ll[6] = {0, 2, 6, 12, 20, 30};

int T;
int n, m;
int t[10];
int a[maxn];
int sing[maxn][10];
vector<int> mov[10][maxn];

void init() {
    t[0] = 1;
    for (int i = 1; i <= 5; i++) t[i] = t[i - 1] * 10;

    int cnt = 0;
    for (int i = 1; i <= 5; i++) {
        for (int j = 1; j <= i; j++) {
            for (int k = j; k <= i; k++)
                sing[cnt + 1][k] = 1, sing[cnt + 2][k] = 9;
            cnt += 2;
        }
    }

    vector<int> now(maxm, 0), lst(maxm, 0);
    int id = 0;

    for (int ttt = 1; ttt <= 5; ttt++) {
        mov[ttt][0].push_back(0);
        int len = ll[ttt];
        lst[0] = ++id;
        for (int i = 1; i <= 50; i++) {
            for (int j = 0; j < t[ttt]; j++) {
                if (lst[j] != id) continue;
                vector<int> tmp(6);
                int x = j;
                for (int k = ttt; k; k--) tmp[k] = x % 10, x /= 10;
                for (int k = 1; k <= len; k++) {
                    int aim = 0;
                    for (int l = 1; l <= ttt; l++)
                        aim += (tmp[l] + sing[k][l] + 10) % 10 * t[ttt - l];
                    now[aim] = id + 1;
                }
            }
            ++id;
            swap(lst, now);
            for (int j = 0; j < t[ttt]; j++)
                if (lst[j] == id) {
                    mov[ttt][i].push_back(j);
                }
        }
    }
}
void print(int x) {
    vector<int> tmp(6, 0);
    for (int k = n; k; k--) tmp[k] = x % 10, x /= 10;
    for (int i = 1; i <= n; i++) putchar(tmp[i] ^ 48);
    putchar('\n');
}
int main()
{
    init();

    T = read();
    while (T--) {
        n = read(); m = read();

        vector<int> cnt(t[n], 0);
        for (int i = 1; i <= m; i++) {
            int x;
            for (int i = 1; i <= n; i++) scanf("%1d", &a[i]);
            x = read();

            for (auto diff : mov[n][x]) {
                vector<int> tmp(6, 0);
                for (int j = n; j; j--) tmp[j] = diff % 10, diff /= 10;

                int aim = 0;
                for (int j = 1; j <= n; j++)
                    aim += (a[j] + tmp[j] + 10) % 10 * t[n - j];
                cnt[aim]++;
            }
        }

        int tot = 0, ans = 0;
        for (int i = 0; i < t[n]; i++)
           if (cnt[i] == m) tot++, ans = i;

        if (tot >= 2) printf("MANY\n");
            else if (tot == 0) printf("IMPOSSIBLE\n");
            else if (tot == 1) print(ans);
    }

    return 0;
}
```