---
title: '牛客多校 2025 - 01 EGHIKL'
description: ''
publishDate: 2025-07-19
tags:
  - ACM
  - 多校
---

别骂了别骂了我现在就去复健

<!-- more -->

### [E - Endless Ladders](https://ac.nowcoder.com/acm/contest/108298/E)

简单手算一下可以发现合法的长度为 $2k - 1(k \geq 1)$ 和 $4k(k \geq 2)$ ，即所有奇数和大于等于 8 的 4 的倍数

分奇偶讨论一下即可

#### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

void solve() {
    int a, b;
    cin >> a >> b;
    int dis = abs(a * a - b * b);

    if (dis & 1) {
        cout << dis / 2 + max(0ll, dis / 4 - 1) << "\n";
    } else {
        cout << dis / 4 * 3 - 2 << "\n";
    }

    //x 3 5 7 9 11 13 15 17
    //   x   8.  12.   16
}

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    cin >> T;
    while (T--) {
        solve();
    }

    return 0;
}
```

### [G - Symmetry Intervals](https://ac.nowcoder.com/acm/contest/108298/G)

假设连续匹配的一段长度为 $l$ ，这一段的贡献就是 $\frac{l \times (l + 1)}{2}$ ，把每一段长度的贡献加起来即可
#### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

void solve() {
    int n, Q;
    string S;
    cin >> n >> Q;
    cin >> S;
    while (Q--) {
        int x;
        string T;
        cin >> T >> x;
        int m = T.length();

        int cnt = 0, ans = 0;
        for (int i = 0; i < m; i++) {
            if (T[i] == S[i + x - 1]) {
                ++cnt;
            } else {
                ans += cnt * (cnt + 1) / 2;
                cnt = 0;
            }
        }
        ans += cnt * (cnt + 1) / 2;
        
        cout << ans << "\n";
    }
}

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    // cin >> T;
    while (T--) {
        solve();
    }

    return 0;
}
```

### [H - Symmetry Intervals 2](https://ac.nowcoder.com/acm/contest/108298/H)

思路来源：题解

---

先预处理所有长度为 $b$ 的二进制串， $(l, r, a)$ 表示这个串左边有 $l$ 个连续的 0 ，右边有 $r$ 个连续的 0 ，这个串内的贡献和为 $a$ （令 0 表示相等，根据前作，就是所有连续的 0 的贡献）

然后将原 01 串划分为 $\lceil \frac{n}{b} \rceil$ 块，每块的状态压缩为一个数字

对于每一个查询，我们可以 $O(1)$ 计算出连续 $b$ 个数字的串，将两个起点的串异或就得到了这 $b$ 个数字的匹配情况，根据预处理的信息即可进行合并。对于全 0 串要特判一下，末尾 0 的数量应该更新为 `+= b` 而不是直接赋值为 `b`

对于更新操作，手动更新范围的第一块和最后一块，中间的部分在差分数组上打标记即可，在查询时再进行更新。

因为查询操作不超过 2500 次，最终复杂度为 $O(\frac{nq_2}{b} + 2^{b})$

时间限制还是有点紧的，尽量避免在循环内使用除法

#### Code
```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

struct node {
    int l, r, sum;
};

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    // cin >> T;
    while (T--) {
        int n, Q;
        string str;
        cin >> n >> Q;
        cin >> str;
        str = " " + str;

        int b = 16;
        vector<node> info(1 << b, {0, 0, 0}); // low, high
        for (int i = 0; i < (1 << b); i++) {
            int cnt = 0;
            for (int j = 0; j < b; j++) 
                if (!(i >> j & 1)) {
                    ++cnt;
                    info[i].sum += cnt;
                } else {
                    cnt = 0;
                }
            for (int j = 0; j < b; j++)
                if (!(i >> j & 1)) ++info[i].l;
                    else break;
            for (int j = b - 1; j >= 0; j--)
                if (!(i >> j & 1)) ++info[i].r;
                    else break;
        }

        vector<int> bit(n / b + 5, 0);
        for (int i = 1; i <= n; i++) {
            if (str[i] == '0') continue;
            int x = (i - 1) % b, id = (i - 1) / b + 1;
            bit[id] |= 1 << x;
        }

        vector<int> rev(n / b + 5, 0);
        auto remix = [&] (int l, int r) -> int {
            if (l == 1) return (1 << r) - 1;
            if (r == b) return ((1 << b) - 1) ^ ((1 << l - 1) - 1);

            int res = (1 << b) - 1;
            res ^= (1 << (l - 1)) - 1;
            res ^= ((1 << b) - 1) ^ ((1 << r) - 1);
            return res;
        };

        auto upd = [&] (int l, int r) {
            int idl = (l - 1) / b + 1, idr = (r - 1) / b + 1;
            if (idl < idr - 1) { // [idl + 1, idr - 1]
                rev[idr] ^= 1, rev[idl + 1] ^= 1;
            }

            int pos;
            if (idl == idr) {
                bit[idl] ^= remix((l - 1) % b + 1, (r - 1) % b + 1);
            } else {
                pos = (l - 1) % b + 1;
                bit[idl] ^= remix(pos, b);
                pos = (r - 1) % b + 1;
                bit[idr] ^= remix(1, pos);
            }
        };
        auto get = [&] (int x, int idx, int posx) -> int {
            if (posx == 0) return bit[idx];

            int res = 0;
            int len = b - posx;
            res |= ((((1 << b) - 1) ^ ((1 << (b - len)) - 1)) & bit[idx]) >> posx;
            len = b - len;
            res |= (((1 << posx) - 1) & bit[idx + 1]) << (b - posx);

            return res;
        };
        auto query = [&] (int len, int l, int r) -> int {
            int rr = 0;
            for (int i = 1; i <= n / b + 1; i++) {
                rr ^= rev[i];
                rev[i] = 0;
                if (rr) bit[i] ^= (1 << b) - 1;
            }

            int res = 0, cnt = 0;
            int idl = (l - 1) / b + 1, posl = (l - 1) % b;
            int idr = (r - 1) / b + 1, posr = (r - 1) % b;
            while (len >= b) {
                int x = get(l, idl, posl), y = get(r, idr, posr);
                int val = x ^ y;

                res += info[val].sum;
                res += cnt * info[val].l;

                if (!val) cnt += b;
                    else cnt = info[val].r;
                l += b, r += b;
                len -= b;
                ++idl, ++idr;
            }

            if (len) {
                for (int i = 1; i <= len; i++) {
                    int tl = l + i - 1, tr = r + i - 1;
                    int idl = (tl - 1) / b + 1, idr = (tr - 1) / b + 1;
                    int posl = (tl - 1) % b, posr = (tr - 1) % b;
                    int x = bit[idl] >> posl & 1, y = bit[idr] >> posr & 1;
                    
                    if (x == y) {
                        ++cnt;
                        res += cnt;
                    } else {
                        cnt = 0;
                    }
                }
            }

            return res;
        };

        while (Q--) {
            int opt;
            cin >> opt;
            if (opt == 1) {
                int x, y;
                cin >> x >> y;
                upd(x, y);
            } else {
                int z, x, y;
                cin >> z >> x >> y;
                cout << query(z, x, y) << "\n";
            }
        }
    }

    return 0;
}
```

### [I - Iron Bars Cutting](https://ac.nowcoder.com/acm/contest/108298/I)

首先不难想到一个 $n^4$ 的 dp，令 $dp_{i, j, k}$ 表示当前处理的范围是 $[i, j]$ ，选择在 $k$ 处切割的最小代价以及此次切割的不平衡度

对于一个状态 $dp_{i, j, k}$ ，最多会产生 $j - i$ 个不同的切割结果，我们对这些切割结果维护一个不平衡度递减，代价递增的单调栈，直接在 $[i, k]$ 和 $[k + 1, j]$ 两个区间上二分即可得到符合要求的最小代价，时间复杂度 $O(n^3logn)$

#### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        vector<int> a(n + 5, 0), s(n + 5, 0);
        for (int i = 1; i <= n; i++) cin >> a[i], s[i] = s[i - 1] + a[i];

        vector<vector<vector<pii>>> stk(n + 5, vector<vector<pii>>(n + 5));

        auto find = [&] (int i, int j, int ba) -> int {
            int l = 0, r = (int)stk[i][j].size() - 1, tag = -1;
            while (l <= r) {
                int mid = (l + r) >> 1;
                if (stk[i][j][mid].first <= ba) r = mid - 1, tag = mid;
                    else l = mid + 1;
            }
            return tag;
        };

        vector<int> ans(n + 5, inf64);
        for (int i = 1; i <= n; i++) stk[i][i].push_back({0, 0});
        for (int len = 2; len <= n; len++) {
            for (int i = 1; i <= n - len + 1; i++) {
                vector<pii> seg;
                int j = i + len - 1;
                for (int k = i; k < j; k++) { // [i, k] [k + 1, j]
                    int l1 = s[k] - s[i - 1], l2 = s[j] - s[k], balance = abs(l1 - l2);
                    int tmp = 0;
                    int tag = find(i, k, balance);
                    if (tag == -1) continue;
                    tmp += stk[i][k][tag].second;
                    tag = find(k + 1, j, balance);
                    if (tag == -1) continue;
                    tmp += stk[k + 1][j][tag].second;
                    seg.push_back({balance, tmp + min(l1, l2) * (int)(ceil(log2(l1 + l2)))});
                    if (i == 1 && j == n) ans[k] = min(ans[k], tmp + min(l1, l2) * (int)(ceil(log2(l1 + l2))));
                }

                ranges::sort(seg, [&](pii x, pii y){return x.first > y.first;});
                for (auto [x, y] : seg) {
                    while (!stk[i][j].empty() && y < stk[i][j].back().second) stk[i][j].pop_back();
                    stk[i][j].push_back({x, y});
                }
            }
        }
        
        for (int i = 1; i < n; i++)
            cout << (ans[i] == inf64 ? -1 : ans[i]) << ' ';
        cout << "\n";
    }

    return 0;
}
```

### [M - Museum Acceptance](https://ac.nowcoder.com/acm/contest/108298/K)

题面看错两次（

---

根据题目移动的规则，对于每个起点，经过的路径一定是一个环，且环与环之间互不相交

直接 dfs 求出每个环的大小即可，时间复杂度 $O(\sum{d_i})$

#### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    // cin >> T;
    while (T--) {
        int n;
        cin >> n;
        vector<array<int, 5>> G(n + 5);
        for (int i = 1; i <= n; i++) {
            cin >> G[i][0];
            for (int j = 1; j <= G[i][0]; j++)
                cin >> G[i][j];
        }

        vector<array<int, 5>> dp(n + 5), vis(n + 5);
        set<pii> st;

        int timeId = 0;
        function<int(int, int)> dfs = [&] (int cur, int doorId) -> int {
            if (vis[cur][doorId] == timeId) {
                return dp[cur][doorId] = st.size();
            }
            vis[cur][doorId] = timeId;

            int nxt = doorId == G[cur][0] ? 1 : doorId + 1;
            int v = G[cur][nxt];
            nxt = 0;
            for (int j = 1; j <= G[v][0]; j++)
                if (G[v][j] == cur) {nxt = j; break;}
            int x = cur, y = v;
            if (x > y) swap(x, y);
            st.insert({x, y});
            dp[cur][doorId] = dfs(v, nxt);

            return dp[cur][doorId];
        };

        for (int i = 1; i <= n; i++) {
            if (!dp[i][G[i][0]]) {
                ++timeId;
                st.clear();
                dfs(i, G[i][0]);
            }
        }

        for (int i = 1; i <= n; i++)
            cout << dp[i][G[i][0]] << "\n";
    }

    return 0;
}
```

### [L - Numb Numbers](https://ac.nowcoder.com/acm/contest/108298/L)

用 `map` 维护一个对顶堆，保证较小数字的数量不超过 $\lfloor \frac{n}{2} \rfloor$ ，答案就是较小数字的数量
#### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

typedef pair<int, int> pii;
typedef long long LL;
typedef unsigned long long uLL;
typedef __int128_t i128;

const int inf32 = 1e9;
const LL inf64 = 1e18;

signed main()
{
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    cin >> T;
    while (T--) {
        int n, Q;
        cin >> n >> Q;
        vector<int> a(n + 5, 0);
        for (int i = 1; i <= n; i++) cin >> a[i];

        int maxCnt = n / 2;
        map<int, int> mn, mx;
        int sizMn = 0, sizMx = 0;
        for (int i = 1; i <= n; i++) mn[a[i]] += 1;
        sizMn = n;

        auto upd = [&] () -> void {
            while (sizMx < maxCnt || (!mn.empty() && mn.rbegin() -> first >= mx.begin() -> first)) {
                auto tmp = *mn.rbegin();
                sizMn -= tmp.second;
                mn.erase(tmp.first);
                sizMx += tmp.second;
                mx[tmp.first] += tmp.second;
            }
            while (sizMx - mx.begin() -> second >= maxCnt) {
                auto tmp = *mx.begin();
                sizMx -= tmp.second;
                mx.erase(tmp.first);
                sizMn += tmp.second;
                mn[tmp.first] += tmp.second;
            }

            if (!mn.empty() && mn.rbegin() -> first == mx.begin() -> first) {
                auto tmp = *mn.rbegin();
                sizMn -= tmp.second;
                mn.erase(tmp.first);
                sizMx += tmp.second;
                mx[tmp.first] += tmp.second;
            }
        };
        auto add = [&] (int x) -> void {
            mn[x] += 1;
            sizMn += 1;
        };
        auto del = [&] (int x) -> void {
            if (mn.count(x)) {
                mn[x] -= 1;
                sizMn -= 1;
                if (!mn[x]) mn.erase(x);
            } else {
                mx[x] -= 1;
                sizMx -= 1;
                if (!mx[x]) mx.erase(x);

            }
        };
        
        upd();
        while (Q--) {
            int x, y;
            cin >> x >> y;
            del(a[x]);
            a[x] += y;
            add(a[x]);
            upd();

            cout << sizMn << "\n";
        }
    }

    return 0;
}
```