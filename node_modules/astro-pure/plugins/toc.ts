import type { MarkdownHeading } from 'astro'

export interface TocItem extends MarkdownHeading {
  subheadings: TocItem[]
}

function diveChildren(item: TocItem, depth: number): TocItem[] {
  if (depth === 1 || !item.subheadings.length) {
    return item.subheadings
  } else {
    // e.g., 2
    return diveChildren(item.subheadings[item.subheadings.length - 1] as TocItem, depth - 1)
  }
}

export function generateToc(headings: readonly MarkdownHeading[]) {
  // this ignores/filters out h1 element(s)
  const bodyHeadings = [...headings]
  const toc: TocItem[] = []

  const minDepth = Math.min(...headings.map(h => h.depth));

  bodyHeadings.forEach((h) => {
    const heading: TocItem = { ...h, subheadings: [] }

    // add min elements into the top level
    if (heading.depth === minDepth) {
      toc.push(heading)
    } else {
        let parentCandidates: TocItem[] = toc;
        let parent: TocItem | undefined;

        while (parentCandidates.length > 0) {
            const lastCandidate = parentCandidates[parentCandidates.length - 1];
            
            if (lastCandidate.depth === heading.depth - 1) {
                parent = lastCandidate;
                break;
            } 
            else if (lastCandidate.depth < heading.depth) {
                parentCandidates = lastCandidate.subheadings;
            } 
            else { //父级层次更深
                const closestParent = findClosestParent(toc, heading.depth);
                if (closestParent) {
                    closestParent.subheadings.push(heading);
                    return;
                }
                toc.push(heading);
                return;
            }
        }

        if (parent) {
            parent.subheadings.push(heading);
        } else {
            toc.push(heading);
        }
      }
  });

  function findClosestParent(items: TocItem[], targetDepth: number): TocItem | undefined {
      if (!items.length) return undefined;
      const lastItem = items[items.length - 1];
      if (lastItem.depth < targetDepth) {
          if (lastItem.subheadings.length > 0) {
              const result = findClosestParent(lastItem.subheadings, targetDepth);
              if (result) {
                  return result;
              }
          }
          return lastItem;
      }
      return undefined;
  }

  return toc
}